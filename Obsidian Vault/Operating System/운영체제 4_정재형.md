# 가상 메모리 개요

**가상 메모리는 하나의 프로세스가 RAM에 일부만 존재해도 수행되는 방법을 제공** 
- RAM보다 크기가 큰 프로세스 수행 가능

**가상 메모리 "Virtual Memory"**: 가상 주소 공간
**실제 메모리 "Main Memory(Pyhsical Memory)"**: 실제 주소 공간

**OS는 VM + MM 을 전체 메모리로 인식
- 전체 메모리는 VM 포함
- VM이 추가되어 많은 프로세스 수행 가능

**CPU입장에선 VM을 물리적으로 직접 접근 불가능**
- 전체 메모리는 VM을 포함하므로, CPU는 VM의 주소를 보고 프로세스를 수행시키는 상황이 발생할 수 있음
- But, VM은 CPU가 접근 불가능하기 때문에, OS는 재빨리 해당 프로세스를 MM으로 이동 -> 이후 **동적 주소 변환**을 통해 CPU가 수행하는 VM 주소를 MM 주소로 변환해 프로세스 수행시킴

## 동적 주소 변환 
**"Dynamic Address Translation"**

프로세스가 수행될 때 가상주소가 실제주소로 변환되는 메커니즘
- **가상 주소 "Virtual Address"**: 프로세스가 VM 에서 **참조**되는 주소
- **실제 주소 "Real Address"**: 프로세스가 MM 에서 이용될 수 있는 주소

**인위적 연속성 "Artificial Continuity"**
- VA 공간상의 연속된 주소들은 MM 에서 반드시 연속적일 필요 없음

### 블록 맵핑 
**"Block Mapping"**

**어느 정도의 크기를 가진 블록단위로 프로그램이 VA 에서 RA 로 이동하는것**
- VA에 위치한 프로그램을 RA로 이동 -> 맵핑 테이블이 방대해져 비효율적

**페이징 "Paging"**
- 블록 맵핑에서 **같은 크기의 블록**을 이용해 이동 시키는법
- 이런 블록을 **페이지**라고 함
- **페이징 기법**: 페이지들로 VM을 구성하는 방법

**세그먼테이션 "Segmentation"**
- 블록 맵핑에서 **다른 크기의 블록**을 이용해 이동 시키는법
- 이런 블록을 **세그먼트**라고 함
- **세그먼트 기법**: 세그먼트들로 VM을 구성하는 방법

# 페이징
**"Paging"**

**동일 크기의 블록을 이용해 VA와 RA를 맵핑**

**페이징 시스템에서 VA는 순서쌍 V=(p,d)로 표현
- **p**: VM 내에서 참조될 항목이 속해있는 **페이지 번호**
- **d**: 페이지 p 내에서 참조될 항목이 위치하고 있는 곳의 변위(Offset)

**페이징 시스템에서의 동적 주소 변환 방법**
- VA는 페이지 맵핑 테이블 "Page Mapping Table"을 통해 실제 주소 계산
- 예로 VA를 v=(p,d) 라고 할 때, 동적 주소 변환 이후 RAM상의 실제 주소 r=(p',d)를 구함

**페이지 맵핑 테이블은 페이지 존재 비트 "Page Residence Bit"를 가짐**
- RAM 내에 페이지가 존재하면 1, 존재하지 않으면 0

## 직접 맵핑 방법
**"Direct Mapping"**

**RAM에 저장되어 있는 페이지 맵핑 테이블을 이용해 동적 주소 변환 수행**

**페이지 맵핑 테이블의 시작 주소는 페이지 맵핑 테이블 시작점 레지스터에 보관

**페이지 맵핑 테이블 내의 내용 참조는 한번의 RAM 주기 시간 내에 수행**

## 연관 맵핑 방법
**"Associative Mapping"**

**별도의 연관 기억장치를 이용해 페이지 맵핑 테이블 전체를 관리**

**연관 기억장치는 병렬 검색이 가능한 고가의 메모리**
- 입력되는 내용을 통해 직접적으로 메모리의 내용 검색 가능
- 직접 맵핑 방법의 주소 기반 검색보다 훨신 빠른 검색 가능

## 연관/직접 맵핑 방법

**연관 맵핑과 직접 맵핑의 장점을 살릴 수 있는 복합 주소 변환 기법

**페이지 맵핑 테이블이 RAM과 연관기억장치에 나누어 관리**

**가장 최근에 참조된 페이지는 조만간 다시 사용되기 쉽다는 사실을 이용**
- 연관기억장치에 페이지 맵핑 테이블의 전체 항목중 가장 최근에 참조된 일부 페이지 정보 저장

**VA를 연관 페이지 맵핑 테이블에서 찾고 없다면 직접 맵핑 테이블에서 찾음**

## 페이징 시스템에서의 공유

**다중 프로그래밍 환경에서 공유가 가능한 페이지는 가능한 공유**
- 예) 10명의 사용자가 문서 처리 프로그램 이용시
- 문서 처리기 프로그램 자체를 위한 페이지는 10명이 공유
- 각 사용자가 이용하는 데이터를 위한 페이지는 별도 사용

## 페이지 크기 설정

**페이지의 크기를 결정하는데 있어 고려할 사항**
- 페이지 크기가 작을수록 프로세스가 메모리 내의 **작업세트**를 확보하는데 도움
- But, 페이지 크기가 작으면 페이지 맵핑 테이블의 크기가 증가 -> 메모리 낭비

- 페이지 크기가 클수록 프로그램 실행 중 VM과의 I/O 전송 횟수를 줄일 수 있음
- But, 페이지 크기가 크면 참조되지 않을 많은 정보까지 RAM으로 옮겨짐 -> 메모리 낭비
>[!note] **작업 세트 "Working Set"**
>실행중인 프로세스가 자주 참조하는 페이지들의 집합
>

## 페이지 반입 기법
**"Fetch"**

**요구 페이징 기법**
"Demand Paging"
- 실행중인 프로세스에 의하여 명백히 참조되는 프로세스만이 VM으로부터 RAM으로 적재됨

**예상 페이징 기법**
"Anticipactory Paging"
- OS가 예측하여 RAM에 여유가 있을 때 사용될것이라고 예상되는 페이지들을 미리 적재


# 세그먼테이션
**"Segmentation"**

**프로그램을 페이지 단위로 분리하는게 아닌, 논리적으로 관련 있는 단위(세그먼트)로 분할**
- 세그먼트 "Segment": 논리적 단위가 되는 프로그램 모듈이나 자료

**세그먼테이션에서의 직접 맵핑 방법**
- v = (s, d) -> r = s' + d

## 세그먼트 맵핑 테이블 항목

**존재 비트 "Resident Bit"**: 해당 세그먼트가 RAM에 현재 존재하는지 여부 = r
- 0 = 세그먼트가 RAM에 없는 경우, 1 = 세그먼트가 RAM에 있는 경우

**세그먼트의 VMA** = a

**세그먼트의 길이** = $l$

**보호비트**: R(판독 접근), W(기록 접근), E(수행 접근), A(첨가 접근)
- 0 = False, 1 = True

**세그먼트의 RMA** = s'

## 세그먼테이션 시스템에서의 공유

**여러개의 페이지가 공유되는 페이징 시스템과 달리, 하나의 세그먼트만 공유됨**

***
# 세그먼테이션/페이징 혼용 기법

**가변적인 세그먼트가 너무 커 RAM에 적재할 수 없을때**
- 정수 배의 페이지로 다시 분할하는 세그먼트/페이징 혼용 기법 이용

## 세그먼트/페이징 혼용 기법
**연관/직접 맵핑을 이용한 동적 주소 변환 방법**
- v = (s, p, d) -> r = p' + d

***
# 페이지 교체 알고리즘

**현재 MM을 차지중인 페이지중 어떤 페이지를 선택해 VM으로 보낼것인가를 결정하는 기법**
- 새로 적재할 페이지를 위함

**종류**
- FIFO "First In First Out"
- 최적 교체 "Optimal Replacement"
- LRU "Least Recently Used"
- 2차 기회 "Second Chance"
- LFU "Least Frequently Used"
- NRU "Not Recently Used" = NUR

## FIFO

**가장 먼저 MM에 존재하는 페이지를 VM으로 이동**

**작동 방식**
- **페이지 요청** "Page Request": 특정 프로그램이 페이지를 요청
- **페이지 적중** "Page Hit": 요청된 페이지가 MM에 존재하면 아무것도 안함
- **페이지 결함** "Page Fault": 요청된 페이지가 MM에 없다면, 페이지 결함이 발생하고 새 페이지를 불러와야함
- **페이지 교체** "Page Replacement": MM이 가득 차있다면, 가장 먼저 들어온 페이지 제거 후 새 페이지 적재

**단점**
- 자주 사용되는 페이지가 교체될 수 있어 "Belady의 이상"이 발생 가능 -> 페이지 결함률 증가

## 최적 교체

**앞으로 가장 오랫동안 사용되지 않을 페이지를 교체** -> 최소의 페이지 부재를 가짐

**But, 페이지 호출 순서에 대한 모든 상황을 미리 파악하고 있어야 구현 가능** -> 비현실적, 구현 어려움

## LRU

**현 시점에서 가장 오래된 페이지를 제거**
- 한 프로세스에서 사용되는 페이지에 타임-스탬프용 카운터 or 스택을 둠

**카운터에 의한 방법**
- 특정 페이지에 참조가 있을때 마다 현재 시간이 페이지 테이블 내의 사용시간 필드에 복사

**스택에 의한 방법**
- 스택의 꼭대기에 있는 페이지 -> 최근 사용됨
- 스택의 바닥에 있는 페이지 -> 가장 오래됨

## 2차 기회

**FIFO 알고리즘의 단점인 최근 사용된 페이지도 교체당하는 상황을 보완한 알고리즘**

**방식**
- **참조 비트**: 각 페이지에는 '참조 비트'가 설정됨, 페이지 참조시 1로 설정
- **페이지 요청**
- **페이지 적중**: 페이지가 존재하면 참조 비트 1로 설정
- **페이지 결함**
- **페이지 교체**: 맨 앞부터 페이지를 검사하여
	- 참조 비트 = 1: 최근 사용된 페이지로 참조 비트 0으로 재설정 -> 큐의 끝으로 보낸 후 다음 페이지 검사
	- 참조 비트 = 0: 최근에 사용되지 않은 페이지로 제거 -> 그자리에 적재

## LFU

**MM의 페이지들 중 가장 적게 참조된 페이지를 교체**

**방식**
- **참조 비트**: 페이지 참조시 카운터 증가
- **페이지 요청**
- **페이지 적중**: 참조 비트 카운터 1 증가
- **페이지 결함**
- **페이지 교체**: 모든 페이지중 가장 적게 참조된 페이지 교체

## NRU

**LRU와 유사하나 구현 비용 적음**

**참조 비트 + 변형 비트 이용**
- 11, 10, 01, 00

**비트가 큰 페이지를 오래 유지**

***
# 쓰레싱

**다중 프로그래밍에서 하나의 프로세스는 실행을 위해 몇 개의 페이지 프레임을 할당 받음**
- ex) 프로세스별 균등 할당, 비례 할당

**페이지 부재가 계속 발생되어 프로세스가 수행되는 시간보다 페이지 교체에 소비되는 시간이 더 많아지는 경우**

**방지를 위해 한 프로세스가 제공 받아야 할 페이지 프레임 수를 알아야함**

**구역성** "Locality"
- 프로세스가 기억장치 내의 모든 정보를 균일하게 참조하는것이 아닌 **국부적인 부분만 집중적으로 참조한다**라는 의미
- **이러한 구역성을 통해 페이지 프레임수를 예측 가능함**

**시간 구역성** "Temporal Locality"
- 최근에 참조된 기억장소가 가까운 미래에도 계속 참조될 가능성이 높음
- ex) 순환, 서브루틴 스택, 카운팅과 집계에 사용되는 변수

**공간 구역성** "Spatial Locality"
- **하나의 기억장소가 참조되면 그 근처의 기억장소가 계속 참조되는 경향이 있음을 의미**
- ex) 배열 수행, 순차 코드의 실행

## 페이지 부재율

**RAM에 프로세스가 수행에 필요로 하는 페이지가 없는 비율
- 페이지 부재율이 높으면, 프로세스가 더 많은 페이지 프레임을 요구
- 페이지 부재율이 낮으면, 프로세스가 너무 많은 페이지 프레임을 가지고 있음

**페이지 부재율의 상한과 하한을 이용하여 페이지 프레임을 동적으로 변경**















