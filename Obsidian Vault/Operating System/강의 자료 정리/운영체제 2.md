### 프로세스 관리

중앙처리장치(CPU)는 컴퓨터 자원 중 가장 중요한 자원임

**프로세스 스케줄링**
- 준비 완료(Ready) 상태에 있는 프로세스들 중 어떤 프로세스를 중앙처리장치에 할당할 것인가 결정하는 정책
- 중앙처리장치의 **처리량** 최대화와 **반환시간**의 최소화를 목표로 함

| 처리량: cpu가 단위당 처리하는 프로세스의 개수      |
| -------------------------------- |
| 반환시간: 각 프로세스가 시작해서 끝날 때까지 걸리는 시간 |

---
프로세스의 다양한 정의(메모리에 로드된 프로그램)
- 실행 중인 프로그램
- PCB(Process Control Block)를 지닌 프로그램
- 프로그램 카운터(Program Counter)를 지닌 프로그램
---
운영체제의 프로세스 관리 기능
- 사용자 프로세스 및 시스템 프로세스의 생성과 삭제
- 프로세스의 일시 중지와 재 수행
- 프로세스 스케줄링 (어떤 프로세스에 CPU를 할당할 것인가?)
- 프로세스 간 동기화 (2개 이상의 프로세스들 간의 동기화는 어떻게?)
- 프로세스 간 통신 (2개 이상의 프로세스 간에 통신은 어떻게?)
- 교착상태 처리 (2개 이상의 프로세스 간에 꽉 막힌 문제는 어떻게?)
---
### 프로세스 구성 요소

임의의 프로그램이 실행되기 위해서는 반드시 실행되기 전에 **주기억장치(메인 메모리)에 로드 되어야 함**
- 주기억 장치에 로드된 프로그램 -> **프로세스(Process)**
---
주 기억장치에 저장되는 프로세스의 구성 요소
- 코드(Code) 영억
	- 프로그램의 코드 자체 (CPU가 해석할 수 있는 바이너리 코드 상태), 실행 명령어 코드
- 데이터 영역
	- 프로그램의 전역변수나 **정적변수**(**Static** variable) 할당
- 스택(Stack) 영역
	- 지역 변수(Local variable)와 함수(메소드) 호출 시 전달되는 인수를 위한 변수
- 힙(Heap) 영역
	- 메모리의 동적 할당을 위한 공간
![[운영체제 2-20240417091429603.webp|250]]
---
### 프로세스의 상태(State)

**준비(완료) 상태(Ready State)**
- cpu가 사용이 가능한 상태, 즉 cpu를 할당 받을 수 있는 상태
- cpu가 프로세스 자신을 처리해 주기를 기다리고 있는 상태

**실행 상태 (Running State)**
- 프로세스가 cpu를 할당 받아서 사용하고 있는 상태

**대기 상태(Block State)**
- 프로세스가 cpu를 양도(반납)하고, 입출력(I/O)을 처리하고 있는 상태
![[운영체제 2-20240417091729945.webp|350]]
---
프로세스의 상태 전환
- 준비 상태 -> 실행 상태 (Dispatch, 디스패치)
- 실행 상태 -> 준비 상태 (Timmer Runout, 시간이 다 됨)
- 실행상태 -> 대기 상태 (Block, cpu 반납하고 입출력 수행)
- 대기 상태 -> 준비 상태(Wakeup, 입출력 완료하고 준비 상태로)

프로세스 스케줄러 내의 Traffic Controller(트레픽 제어기)가 프로세스의 상태를 전환함

---
### 프로세스 제어 블록 (PCB)

프로세스 제어 블록 (PCB, Process Control Block)
- Process Descriptor(프로세스 설명)라고도 함
- 운영체제가 프로세스에 관한 정보를 유지 관리하기 위하여 이용하는 자료구조

PCB: 프로세스에 관련된 정보를 가지고 있는 데이터 구조(테이블 구조)
- 프로세스 생성 시에 만들어짐
- 프로세스 수행  완료시에 삭제 됨 
- 프로스세 스케줄러 내의 Traffic Controller에 의하여 내용이 수정될 수 있음
---
PCB 구성 형태 (PCB에 포함되는 정보)
- 프로세스의 현재 상태(실행, 준비, 대기)
- 프로세스의 고유 id (identifier)
- 프로세스의 우선순위
- 프로세스가 적재된 기억장치의 주소를 가리키는 포인터
- 프로세스에 할당된 자원(장치 등)을 가리키는 포인터
- 프로그램 카운터 (프로세스 내에서 다음에 실행해야 할 명령어 주소)
- CPU 내에 있는 각종 레지스터의 상태 정보를 저장하기 위한 공간

※ CPU도 자체적으로 메모리를 가지고 있음 -> **레지스터 (Register)**

---
(참고) 저장 유영 지정자 register
- 레지스터(register)에 변수를 저장
	- 입출력 속도가 빠름
---
### 프로세스 생성
Unix, Linux 운영체제 환경에서 프로세스에서 새로운 프로세스를 생성시키는 명령어
- C언어 프로그램을 이용할 때, fork() 함수를 이용하면 됨
- 부모 프로세스와 자식 프로세스(하나의 프로그램, 두개의 프로세스)
![[운영체제 2-20240417094721354.webp|350]]
---
### 프로세스 스케줄링
프로세스 스케줄링의 목적
1. **공정성 (무한 대기 방지)**
2. **처리 능력 최대화 (단위 시간 내에 최대한의 프로세스 수행)**
3. **응답 시간의 최소화 (사용자에 대한 빠른 응답)**
4. 예측 가능 (동일 프로세스는 거의 같은 비용 및 시간 내에 수행되어야 함)
5. **오베해드(overhead)의 최소화 (낭비되는 자원 최소화)**
6. 자원 사용의 균형 유지
7. **빠른 응답과 자원 이용 간의 균형 유지 (효과적인 자원 활용 vs 실시간 시스템)**
8. **실행의 무한한 지연을 피할 것**
9. 우선순위제 실시
10. 주요 자원들을 차지하고 있는 프로세스에게 우선권을 부여
11. 좀 더 바람직한 동작을 보이는 프로세스에게 더 좋은 서비스 제공
12. **시스템의 과중한 부하 감소**

-> **이러한 스케줄링의 목적들 간의 상호 충돌이 발생함 (스케줄링이 복잡함)**

---
프로세스 스케줄링에서 고려해야 할 사항들
1. 입출력 위주의 프로세스인가?
2. 연산 위주의 프로세스인가?
3. 프로세스가 일괄 처리형인가 대화형인가?
4. 긴급한 응답이 요구되는가? (예: 실시간 처리 시스템)
5. 프로세스의 우선순위가 필요한가?
6. 높은 우선순위를 지나는 프로세스에 의해서 얼마나 자주 프로세스가 선점(preempted) 되는가?
7. 프로세스가 받은 실행 시간은 얼마나 되는가?
8. 프로세스가 완전히 처리되는 데 필요한 시간은 얼마나 더 요구디는가?(예측)
9. 프로세스가 페이주 부재(page fault)를 얼마나 자주 발생시키는가?
---
프로세스 스케줄링의 단계별 분류
1. 상위 단계 스케줄링 (1 단계 스케줄링)
	- '승인 스케줄링'이라고도 함
	- **작업이 시스템에 들어오는 것을 승인함** (**작업이 준비상태 큐로 들어옴**, _제시 -> 준비_)
2. 중간 단계 스케줄링 (2단계 스케줄링)
	- **프로세스들에 대한 일시적인 활동의 중단 및 재개를 수행함** (_실행 -> 준비 또는 대기_)
3. 하위 단계 스케줄링 (3단계 스케줄링)
	- **어떤 준비 상태의 프로세스(Ready process)에게 중앙처리장치를 할당할 것인가를 결정함** (_준비 -> 실행_)
![[운영체제 2-20240417095742454.webp|500]]
---
프로세스 스케줄링 방식별 분류
1. 선점/비선점(preemptive/non preemptive) 스케줄링 방식
	- 비선점(non preempitve) 스케줄링
		- **하나의 프로세스에 중앙처리장치가 할당되면 그 프로세스의 수행이 끝날 때까지 중앙처리장치는 그 프로세스로부터 빠져나올 수 없음**
		- 응답 시간 예측이 가능함
		- 짧은 작업의 프로세스가 긴 작업의 프로세스를 기다리는 경우 종종 발생
	- 선점(preemptive) 스케줄링
		- **하나의 프로세스가 중앙처리장치를 차지하고 있을 때 다른 프로세스가 현재 수행 중인 프로세스를 중지시키고 중앙처리장치를 차지할 수 있음**
		- 우선순위가 높은 프로세스를 먼저 수행할 때 유리함
		- 실시간 시스템 또는 사분할 시스템에서 빠른 응답 시간 보장 가능
		- **이전에 수행되던 프로세스의 정보(context)를 별도로 유지 관리해 두어야 하는 오버헤드(부담) 발생** -> _context switching(문맥 교환)_ **부담 발생**
---
2. 우선순위(priority) 스케줄링 방식
	- **non preemtive와 preemptive의 두 가지 방식으로 구현 가능함**
	- **우선순위가 각 프로세스에게 주어지며, 중앙처리장치는 가장 높은 우선순위를 가진 프로세스에 할당 됨**
		- 내부적 요인(제한시간, 메모리 요구량, 개방된 파일의 수 등)과 외부적 요인(프로세스 중요성, 사용 부서 등의 정책적 요인)을 이용하여 우선순위 할당 가능
	- **(문제점) 무한대기 또는 기아 현상 발생 위험**
		- 낮은 우선 순위의 프로세스들이 중앙처리장치를 할당 받지 못하는 경우를 의미함
	- **에이징(Aging) 기법으로 무한 대기와 기아 현상 문제 해결**
		- 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 시간이 지남에 따라 점진적으로 증가시킴
	- **각 프로세스에게 우선순위를 부여하여 우선순위가 높은 순서대로 처리하는 방법**
	- **정적 우선순위(static priority) 기법**
		- 상대적으로 오베헤드는 적으나, 주위 여건의 변화에 적응하지 못하고 우선순위를 바꾸지 않음
	- **동적 우선순위(dynamic priority) 기법**
		- 필요에 따라 우선순위 재구성, 주변 상황 변화에 잘 적응하나, 복잡하고 오버헤드가 많아짐
---
3. _기한부(deadline) 스케줄링 방식_
	- 작업들이 명시된 시간이나 기간 내에 완료되도록 계획하는 스케줄링
	- **실시간 시스템에 유요하게 적용 가능함**
	- 그러나, 실제 적용에는 많은 어려움이 있음
		- 사용자는 사전에 작업이 요구하는 정확한 자원을 제시해야 함
		- 다른 사용자 작업에 영향을 미치지 않고 기한부 작업을 수행해야 함
		- 기한까지 작업을 끝내기 위하여 자원 배분을 신중히 해야 함
		- 많은 수의 기한부 작업이 동시에 실행되는 경우, 스케줄링이 너무 복잡해짐
		- 기한부 스케줄링에 따른 집중적 자원 운영은 많은 오버헤드를 발생시킴
	- **실시간 시스템의 스케줄링 방식**
		- 정적(static)스케줄링 방식: 시스템에 의해 실행되는 작업 집합이 미리 정의되어 있는 경우
		- Ex. **RM(Rate Monotonic) 알고리즘: 대표적인 정적 스케줄링 방식. 작업 주기짧을수록 더 높은 우선순위 부여**
		- 동적(dynamic)스케줄링 방식: 작업의 발생 시간이나 특성을 미리 예측할 수 없을 경우에 유용, 보장된 주기의 시간 내에 서비스를 보장
		- Ex. **EDF(Earliest-Deadline First)알고리즘** : 대표적인 동적 스케줄링 방식, **임계 시간이 가장 근접한 테스크를 가장 먼저 수행하는 방식**
---
4. _다중 프로세서 (Multiple Processor) 스케줄링 방식_
	- **프로세서들의 형태가 동일한 동질 시스템 또는 서로 다른 이질 시스템 존재**
	- **이질 시스템의 경우 각 프로세서는 자신의 프로세스를 위한 준비 큐(Ready queue)가 각각 있으며 자신만의 스케줄링 알고리즘을 가지게 됨**
	- 프로세서(CPU)들이 동질일 경우 **로드 밸런싱(load balancing)** 을 수행해야 함
	- 동질 시스템에서 두 가지 스케줄링 방식
		1. 각 프로세서(CPU)가 스스로 스케줄링하며, 공동 준비 큐를 조사하여 실행할 프로세스를 선택함
		2. 한 프로세서(CPU)가 다른 프로세서(CPU)를 위한 스케줄러로서 지정되어 주종 구조(master slave structure)를 구성함
---
### 프로세스 스케줄링 알고리즘
_FCFS (First Come First Served) 스케줄링_
- **비선점 방식**
- 가장 간단한 스케줄링 알고리즘
- **프로세스들이 준비 상태의 큐에 도착한 순서에 따라 cpu를 할당 받음**
- 다른 알고리즘에 비해 작업 완료시가늘 예측하기가 용이함
- 특정 프로세스에 대하여 빠른 응답 시간 보장 안됨
- **긴 작업이 짧은 작업을 오래 동안 기다리게 할 수 있고, 중요하지 않은 작업이 중요한 작업을 기다리게 할 수 있음** _(불합리 발생)_
- 호위 효과(convoy effect)
	- 먼저 도착한 프로세스가 cpu에서 수행되는 버스트 시간이 매우 길면, 그 다음 도착한 프로세스가 첫 번째 프로세스가 끝날 때까지 매우 긴 시간을 기다리게 됨
![[운영체제 2-20240417131241803.webp|450]]
---
_FCFS 스케줄링에서 평균 대기 시간 & 평균 반환 시간(Turnaround time)_

| 프로세스 | 버스트 시간 (burst time : CPU 사용 시간) |
| :--: | :-----------------------------: |
|  P1  |              21ms               |
|  P2  |               3ms               |
|  P3  |               6ms               |
- _프로세스 도착 순서 (P1 -> P2 -> P3 순서 가정)_
	- P1, P2, P3의 대기시간: 0, 21, 24
	- P1, P2, P3의 **평균 대기 시간** : (0 + 21 + 24) / 3 =15
	- P1, P2, P3의 반환 시간 (대기 시간 + burst 시간) : 21, 24, 30
	- P1, P2, P3의 평균 반환 시간 : (21 + 24 + 30) / 3 = 25
![[운영체제 2-20240417131748929.webp]]
-  _프로세스 도착 순서 (P2 -> P1 -> P3 순서 가정)_
	- P1, P2, P3의 대기시간: 3, 0, 24
	- P1, P2, P3의 **평균 대기 시간** : (3 + 0 + 24) / 3 = 9
	- P1, P2, P3의 반환 시간 (대기 시간 + burst 시간) : 24, 3, 30
	- P1, P2, P3의 **평균 반환 시간** : (24 + 3 + 30) / 3 = 19
![[운영체제 2-20240417132014755.webp]]
---
_SJF(Shortest Job First) 스케줄링_
- 비선점 방법
- 프로세스 중에서 수행시간이 가장 짧은 것을 먼저 수행하는 비 선점 스케줄링
- FCFS 보다 평균 대기시간을 감소시킴
- (문제점) 수행될 프로세스나 프로세스가 얼마나 긴 것인가를 정확히 알아야 하는데, 이 정보를 얻기가 어려움
	- 사용자가 제공하는 정보에 의존
	- 부정확한 정보, 거짓 정보의 위험 존재
![[운영체제 2-20240417132148028.webp]]
---
_SJF(Shortest Job First) 방식 vs FCFS 방식의 평균 반환 시간 비교_

| 프로세스 | 버스트 시간 (burst time : CPU 사용 시간) |
| :--: | :-----------------------------: |
|  P1  |               7ms               |
|  P2  |               8ms               |
|  P3  |               3ms               |
|  P4  |               6ms               |
- SJF 방식의 평균 반환 시간
	- P1, P2, P3, P4의 반환 시간: 16, 24, 3, 9
	- P1, P2, P3, P4의 평균 반환 시간: (16 + 24 + 3 + 9) / 4 = 13
![[운영체제 2-20240417132358388.webp|400]]
- FCFS 방식의 평균 반환 시간
	- P1, P2, P3, P4의 반환 시간: 7, 15, 18, 24
	- P1, P2, P3, P4의 평균 반환 시간: (7 + 15 + 18 + 24) / 4 = 16
---
_SRT(Shortest Remaining Time) 스케줄링 (또는 SRTF 스케줄링)_
- **선점 방법, SJF(Shortest Job First) 기법에 선점 방식을 도입**
- **새로 도착한 프로세스를 포함하여 처리가 완료되는 데 가장 짧은 시간이 소요된다고 판단되는 프로세스를 먼저 수행함**
	- 실행중인 프로세스라도 남은 처리시간이 더 짧다고 판단되는 프로세스가 큐에 들어오면 언제라도 실행중인 프로세스가 선점됨
	- 수행중인 각각의 작업들에 대한 실행시간을 추적 보유해야 함 (오버헤드)
![[운영체제 2-20240417132759724.webp]]
---
_SJF와 SRT의 평균 대기 및 평균 반환 시간 비교_
- SRT는 프로세스들의 도착시간이 필요함

| 프로세스 | 버스트 시간 | 도착시간 |
| :--: | :----: | ---- |
|  P1  |   6    | 0    |
|  P2  |   4    | 1    |
|  P3  |   2    | 2    |
|  P4  |   2    | 3    |
- 기존 SJF 방식의 평균 대기 및 반환 시간
	- P1, P2, P3, P4의 평균 대기 시간:(0 + (10 - 1) + (6 - 2) + (8 - 3) ) / 4 = 4.5
	- P1, P2, P3, P4의 평균 반환 시간:(6 + (14 - 1) + (8 - 2) + (10 - 3) ) / 4 = 8
![[운영체제 2-20240417133105780.webp]]
---
- SRT 방식의 평균 대기 및 반환 시간(**선점 가능**)
	- P1, P2, P3, P4의 평균 대기 시간:
	 ( (0 + (9 - 1) + (1 - 1) + (6 - 2) ) + (2 - 2) + (4 - 3) ) / 4 = 3.25
	- P1, P2, P3, P4의 평균 반환 시간:
	 (14 + (9 - 1) + (4 - 2) + (6 - 3) ) / 4 = 6.75
![[운영체제 2-20240417133438176.webp]]
---
_라운드 로빈(Round-Robin)스케줄링_
- **선점 방법, 시분할 시스템을 위하여 고안됨**
- 각 프로세스는 순서대로 같은 크기의 중앙처리장치 시간을 할당 받으며, 할당 시간 내에 완료되지 못하면, 준비 큐의 가장 뒤로 보내짐
	- cpu 할당시간(time quantum)의 크기는 보통 10에서 100ms 사이
![[운영체제 2-20240417134757180.webp|400]]
- 할당 시간이 너무 큰 경우
	- **FCFS 방식과 똑같이 동작함** (한번의 cpu 할당에 프로세스가 완료됨)
- 할당 시간이 너무 작은 경우
	- **문맥 교환(Context Switching)을 위한 오베헤드가 크게 발생함**
	- 결과적으로 대부분의 시간이 cpu를 할당하는데 소모됨
- cpu 할당 시간에 따른 문맥 교환 (Context Switching) 횟수
	- cpu 할당 시간이 각각 11ms, 8ms, 2ms로 결정되는 경우
![[운영체제 2-20240417135103404.webp|400]]
---
_다단계 큐 (Multilevel Queue) 스케줄링_
- **선점 방법**
- 다단계 큐 스케줄링 알고리즘은 **프로세스들을 위한 준비 큐를 다수의 별개 큐로 구분하여 스케줄링**
	- 기억장치의 요구량이나 프로세스의 우선순위 혹은 프로세스의 유형과 같은 프로세스의 특성에 근거해 프로세스들은 해당 큐에 진입하게 됨.
	- 각 큐는 자신의 스케줄링 알고리즘을 가지고 있음
		- Ex. 대화형 작업을 위한 큐는 라운드 로빈 스케줄링 알고리즘 적용. 일괄처리 작업을 위한 큐는 FCFS 스케줄링 알고리즘 적용
	- 일괄처리 작업이 실행 중일지라도 **상위 단계 큐에 작업이 들어오면 일괄처리 작업은 상위 단계 프로세스 작업에 의하여 CPU를 '선점'당함**
- 다단계 큐 스케줄링 알고리즘은 프로세스들을 위한 준비 큐를 다수의 별개 큐로 구분하여 스케줄링
	- 기억장치의 요구량이나 프로세스의 우선순위 혹은 프로세스의 유형과 같은 **프로세스의 특성에 근거해 프로세스들은 해당 큐에 진입하게 됨.**
![[운영체제 2-20240417135723232.webp|500]]
---
_다단계 피드백 큐 (Multilevel Feedback Queue) 스케줄링_
- **선점 방법**
- 프로세스들은 cpu의 사용시간에 따라 입출력 위주와 cpu 위주 프로세스로 구분되는데 이를 기준으로 서로 다른 cpu 할당시간을 부여할 필요가 있음
- **새로운 프로세스는 큐잉 네트워크(queueing network)의 단계 1 큐에 추가되어, 그 프로세스는 FCFS에 의하여 CPU를 할당 받음 (높은 우선 순위 배정)**
- 프로세스가 끝나기 전에 할당된 시간이 만료되거나 입출력 등으로 인하여 CPU를 양도한다면 그 프로세스는 그 다음 하위 단계의 큐로 이동되어 순서를 기다림
- **마지막 단계의 큐에서는 그 프로세스가 완료될 때까지 Round Robin 방식으로 스케줄링 됨**
---
- **다단계 피드백 큐 스케줄링 기준**
	- 짧은 작업에 유리
	- 효율적인 입출력 장치 이용을 위하여 입출력 위주 프로세스에 우선권 제공
	- 가능한 한 빨리 작업의 턱성을 알고 그에 맞게 스케줄링을 변경
	- 대부분의 다단계 피드백 체계에서는 프로세스가 하위 단계의 큐로 옮겨갈수록 주어지는 cpu 할당시간을 크게 설정함
![[운영체제 2-20240417142140761.webp|400]]
---
_HRN (High Response ratio Next) 스케줄링_
- **비선점 방법**, 일단 한 작업이 cpu를 차지하면 그 작업은 완성될 때 까지 실행됨
- **SJF 스케줄링의 약점인 긴 작업과 짧은 작업간의 지나친 불평등을 보완한 기법**
- 우선 순위 계산식에서 시스템 응답시간이 클수록 우선순위가 높아짐
![[운영체제 2-20240417142358655.webp]]
- **짧은 작업이나 대기 시간이 큰 작업일수록 우선순위가 높아짐**
- **에이징(Aging)의 구현 방법**

| 프로세스 | 대기 시간 | 버스트 시간 |
|:--------:|:---------:|:-----------:|
|    P1    |    16     |      4      |
|    P2    |    10     |      5      |
|    P3    |     7     |      7      |
|    P4    |    18     |      6      |
 - P1의 시스템 응답시간 = (16+4) / 4 = 5
 - P2의 시스템 응답시간 = (10+5) / 5 = 3
 - P3의 시스템 응답시간 = (7+7) / 7 = 2
 - P4의 시스템 응답시간 = (18+6) / 6 = 4
-  P1 → P4 → P2 → P3의 우선순위에 따라 CPU를 할당 받음
- ---
### 스레드(Thread)
스레드와 프로세스 관계
![[운영체제 2-20240417142610314.webp|500]]

스레드와 프로세스가 포함하는 정보 비교
![[운영체제 2-20240417142627653.webp|400]]

---
_다중 스레드(Multithreads)_
- 코드 영역, 데이터 영역, Heap 영역의 정보는 모든 스레드들이 상호 공유
- 스택 영역 (지역변수 저장)과 레지스터 정보는 스레드 별로 개별 관리
![[운영체제 2-20240417142732790.webp|400]]
---
_다중 스레드의 이용_
- 다수의 스레드를 이용하여 하나의 프로그램을 동시에 처리하는 것
- 하나의 프로세스 자체에 다수의 실행 단위들이 존재하여 작업의 수행에 필요한 자원들을 공유
- 중량 프로세스(HWP : Heavy Weight Process)는 하나의 스레드를 가진 프로세스
- 경량 프로세스(LWP : Light Weight Process)는 프로세스 내에 두 개 이상의 스레드를 포함하고 있을 경우
---
_스레드의 특징_
- 각 스레드는 서로 독립적으로 수행됨
- 프로세스 내에 여러 개의 스레드가 존재
- 프로세스 내의 메모리를 스레드들이 공유하여 사용
- 스레드는 프로세스의 일부분이기 때문에 프로세스의 자원들을 공유하지만 그 자신의 처리 시간과 스택, 레지스터들이 할당됨
- **프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠름(문맥 교환 빠름)**
- **스레드의 실행/종료 순서는 예측할 수 없음**
- **스레드는 서로 독립적이지만, 한 스레드가 취한 행동은 프로세스에 있는 다른 스레드에 영향을 미침 (두 개 이상의 쓰레드가 공유 변수 사용 시 문제 발생 위험)**
---
## 요약
##### 프로세스 (Process)
- PCB를 가지는 실행 중인 프로그램
##### 프로세스 스케줄링
- 어떤 프로세스에 언제 어떠한 방법으로 중앙처리장치를 할당할 것인가에 대한 정책을 수립하는 것
- FCFS, SJF, 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐, HRN 등의 스케줄링 방법이 있음
##### 스레드
- 스레드는 프로세스의 일부분이기 때문에 프로세스의 자원들을 공유하지만 그 자신의 처리 시간과 스택, 레지스터 정보를 보유하고 있음
- 멀티 스레딩