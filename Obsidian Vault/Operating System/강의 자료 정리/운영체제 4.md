# 가상메모리
**하나의 프로세스 전체가 한 번에 주기억장치 내에 존재하지 않고 일부만 있어도 수행되는 방법을 제공**

**주기억장치보다 크기가 큰 프로세스 수행이 가능해짐**
- 가상 메모리: _가상 주소 공간_ 을 가짐
- 실제 메모리: _실제 주소 공간_ 을 가짐

**운영체제 입장 : 가상 메모리 + 실제 메모리 전체를 메모리로 인식**
- **전체 메모리는 가상 메모리를 포함**
- 가상 메모리가 추가되어 많은 프로세스 수행 가능

CPU  입장 : **가상메모리(디스크)** 를 물리적으로 직접 접근할 수 없음
- 전체 메모리는 가상 메모리를 포함하므로 CPU는 가상 메모리의 주소를 보고 프로세스를 수행시키는 상황이 발생할 수 있음
- But, 가상 메모리는 CPU가 접근할 수 없기 때문에 운영체제는 재빨리 해당 프로세스를 실제 메모리로 이동시키고, 운영체제는 _동적 주소 변환_ 을 통하여 CPU가 수행하고 있는 가상 메모리 주소를 실제 메모리 주소로 변환시켜 프로세스를 수행하게 함
- ---
### **동적 주소 변환**
- _프로세스가 수행될 때 가상 주소가 실제주소로 변환되는 메커니즘_
	- **가상주소** : 프로세스가 _가상메모리에서 참조되는 주소_
	- **실제주소** : _실제 메모리에서 이용될 수 있는 주소_
- **인위적 연속성**
	- 가상주소 공간상의 연속된 주소들이 _실기억 공간에서 반드시 연속적일 필요 없음_
---
### 동적 주소 변환에서 **블록 사상 기법** 이용
- 어느 정도 크기를 가진 블록 단위로 가상 주소에서 실제 주소로 프로그램이 이동하게 됨 → **블록 사상 기법**
- 가상주소에 위치한 프로그램의 실제주소로 Mapping을 byte 단위로 수행한다면 ? → **Mapping(사상) 테이블이 방대해서 비효율적임**
---
- 블록 사상 기법에서 **같은 크기의 블록을 이용**하여 이동하는 방법
- 이들 블록을 **페이지 Page** 라고 함
---
##### **페이징(Paging)** 기법 
- 페이지(Page)들로 가상 메모리 구성 방법

블록 사상 기법에서 서로 **다른 크기의 블록을 이용**하여 이동하는 방법
- 이들 블록을 **세그먼트(Segment)** 라고 함
- **세그먼테이션** : 세그먼트들로 가상 메모리 구성방법
---
### 페이징(Paging)
- **동일한 크기의 블록을 이용**하여 가상 주소와 실제 주소 매핑 
- **페이징 시스템에서의 가상 주소는 순서쌍** _v = (p, d)_ 로 표현됨
	- p는 가상 메모리 내에서 참조될 항목이 속해 있는 **페이지 번호**
	- d는 페이p내에서 참조될 항목이 위치하고 있는 곳의 **변위(offset)**
![[운영체제 4-20240417205656409.webp|400]]
##### 페이징 시스템에서의 동적 주소 변환 방법
- 가상 주소는 **페이지 사상 테이블**을 통해 실제 주소 계산
- 가상 주소를 **v = (p, d)** 라고 할 때, 동적 주소 변환 이후 주기억장치상의 실제 주소 **r = p' + d**를 구함
- 페이지 사상 테이블은 **페이지 존재 비트**를 가짐
	- 주기억장치 내에 페이지 존재할 때 '1'로 표시, 존재하지 않을 때 '0' 으로 표시
---
##### 페이징 시스템에서의 동적 주소 변환 방법
1. **직접 사상 방법**
	- 주기억장치에 저장되어 있는 **페이지 사상 테이블**을 이용하여 동적 주소 변환을 수행
	- 페이지 사상 테이블의 시작 주소는 **페이지 사상 테이블 시작점 레지스터**에 보관
	- 페이지 사상 테이블 내의 내용 참조(읽기)는 **한 번의 주기억장치 주기 시간(cycle time)** 내에 수행됨
![[운영체제 4-20240417210017458.webp|550]]
2. **연관 사상 방법**
	- **별도의 연관 기억장치를 이용하여 페이지 사상 테이블 전체를 관리함**
	- 연관 기억장치는 **병렬 검색이 가능**한 고가의 메모리임
	- 입력되는 내용을 통하여 직접적으로 메모리의 내용 검색 가능
	- 직접 사상 방법의 주소 기반 검색보다 훨씬 빠른 검색 가능
![[운영체제 4-20240417210126580.webp|550]]
3. **연관/직접 사상 방법**
	- 연관 사상 및 직접 사상의 장점을 살릴 수 있는 복합 주소 변환 기법
	- 페이지 사상 테이블이 주기억장치와 연관기억장치에 나누어서 관리됨
	- 가장 최근에 참조된 페이지는 조만간 다시 사용되기 쉽다는 사실을 이용함
		- **연관기억장치에 페이지 사상 테이블의 전체 항목 중 가장 최근에 참조된 일부 페이지 정보를 저장**
	- **(방법) 가상 주소를 연관 페이지 사상 테이블에서 찾고, 없으면 직접 사상 테이블에서 찾음**
![[운영체제 4-20240417210313897.webp|500]]
---
### 페이징 시스템에서의 **공유**
- **다중 프로그래밍 환경에서 공유가 가능한 페이지는 가능한 공유 됨**
---
### 페이지 크기를 결정할 때, 고려해야 할 사항
- 페이지 크기가 작을수록 프로세스가 메모리 내의 작업세트(working set)를 확보하는데 도움 _(working set: 실행중인 프로세스가 자주 참조하는 페이지들의 집합)_
- but, 페이지 크기가 작으면 작을수록 페이지 사상 테이블의 크기가 증가하여 메모리가 낭비됨
---
- 페이지 크기가 클수록 프로그램 실행 중 가상 메모리와의 입출력 전송 횟수를 줄일 수 있음
- but, 페이지의 크기가 크게 되면 참조되지 않을 많은 정보들까지 주기억장치로 옮겨지게 되어 메모리의 낭비를 초래할 수 있음
---
### 페이지 반입 기법
##### 요구 페이징 기법
- 실행 중인 프로세스에 의하여 명백히 참조되는 프로세스만이 가상 메모리로부터 메인 메모리(주기억장치)로 적재됨
##### 예상 페이징 기법
- 운영체제가 예측하여 주기억장치에 여유가 있을 때 사용될 것이라고 예상되는 페이지들을 미리 적재함
---
### 세그먼테이션(Segmentation)
**프로그램을 고정 크기 단위(페이지)로 분할하는 것이 아니라, 논리적으로 관련이 있는 단위(세그먼트)로 분할하는 방식**
- 세그먼트: 논리적 단위가 되는 프로그램 모듈이나 자료 구조
##### **세그먼테이션에서 _직접 사상 방법_**
- 가상 주소는 **v = (s, d)** 로 표현됨
![[운영체제 4-20240417210748180.webp|400]]
![[운영체제 4-20240417210811544.webp|550]]
##### 세그먼트 사상 테이블 항목
- 존재 비트: 해당 세그먼트가 주기억장치에 현재 존재하는지 여부
- 세그먼트의 가상 메모리 주소
- **세그먼트 길이**
- 세그먼트의 실제 메모리 주소
![[운영체제 4-20240417210922322.webp|500]]
##### 세그먼테이션 시스템에서 세그먼트 **공유**
- 페이징 시스템보다 단순
	- 페이징 시스템의 경우, 여러 개의 페이지가 공유되어야 할 필요성이 있음
	- 세그먼테이션은 하나의 세그먼트만 공유하면 됨
![[운영체제 4-20240423103720114.webp|350]]
---
### 세그먼테이션/페이징 혼용 기법
가변적인 세그먼트가 너무 커서 주기억장치에 적재할 수 없는 문제 발생시 해결 방법
- **너무 큰 세그먼트를 정수 배의 페이지로 다시 분할하는 _세그먼트/페이징 혼용 기법_ 이용**

가상 주소가 **v = (s, p, d)** 로 구성됨
![[운영체제 4-20240417211148613.webp|400]]

**세그먼트/페이징 혼용기법**에서 **연관/직접 사상**을 이용한 동적 주소 변환 방법
![[운영체제 4-20240417211226187.webp|550]]

---
### 페이지 교체 알고리즘
현재 메인 메모리를 차지하고 있는 페이지들 중에서 **어떤 페이지를 선택하여 가상 메모리 공간으로 보낼 것인가를 결정하는 기법**을 의미

- **FIFO**(First In FirstOut) 알고리즘
- **최적 교체**(Optimal Replacement) 알고리즘
- LRU(Least Recently Used) 알고리즘
- 2차 기회(second chance) 알고리즘
- LFU(Least Frequently Used) 알고리즘
- NRU(Not Recently Used) 알고리즘 (=NUR)
---
##### **FIFO(First In First Out)** 알고리즘
- 가장 간단
- 가장 먼저 메인 메모리에 들어와 있는 페이지를 교체

- FIFO 모순(anomaly) 또는 Belady의 이변
	- 어떤 페이지 호출에서는 프로세스에 할당된 페이지 프레임의 수가 증가될 때 현실적으로 _페이지 부재(Page Fault)_ 가 **더 증가하는 모순** 발생
##### **최적 교체(Optimal Replacement)** 알고리즘
- 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체
- 최소의 페이지 부재율을 가지는 알고리즘
- FIFO 모순 피할 수 있음
- **But, 페이지 호출 순서에 대한 모든 상황을 사전에 미리 파학하고 있어야 하기 때문에 비현실적**
##### **LRU(Least Recently Used)** 알고리즘
- 한 프로세스에서 사용되는 각 페이지마다 **타임-스탬프용 카운터(counter)나 스택**을 두어 **현시점에서 가장 오래 전에 사용된 페이지를 제거하는 방법**
- 페이지 사용시간을 기록하기 위하여 카운터 또는 스택의 사용이 필요함
- 구연이 어려움

카운터에 의한 방법
- 어떤 페이지에 대한 참조가 있을 때마다 현재 시간 레지스터의 내용이 페에지 테이블 내에 있는 사용 시간 필드에 복사
스택에 의한 방법
- 스택의 꼭대기에 있는 페이지가 가장 최근에 사용된 것임을 나타내고 바닥(bottom)에 있는 것이 가장 오랫동안 사용되지 않는 페이지

##### **2차 기회(second chance)** 알고리즘
- 오랫동안 주기억장치에 있던 페이지 중에서 자주 사용되는 페이지의 교체를 방지하기 위한 방법
- FIFO 단점 보완
- 각 페이지마다 참보 비트를 두고, FIFO 기법을 이용하여 페이지 교체 수행중에
	- **참조 비트가 0일 경우에는 해당 페이지를 교체함 (가상기억장치로 이동)**
	- **참조 비트가 1일 경우에는 참조 비트를 0으로 만들고 FIFO 리스트의 맨 마지막으로 이동시킴**
- **교체 대상이 되기 전에 참조 비트를 검사하여 1일 경우에 한번의 기회를 더 부여하기 때문에 ‘2차 기회’ 알고리즘이라고 함**

##### **LFU(Least Frequently Used)** 알고리즘
- 가장 참조 횟수가 적은 페이지를 교체

##### **NRU(Not Recently Used)** 알고리즘 (= NUR)
- 최근에 사용되지 않은 페이지는 가까운 미래에 사용되지 않는 경향에 따라 그것들을 참조되는 페이지와 교체시킴
- LRU와 유사하나, 구현비용이 낮음 (클럭이나 스택 구현 필요 없음)
- 두 개 비트 이용 (참조비트+변형비트): 11, 10, 01, 00
- 숫자가 큰 페이지를 오래 유지함
--- 
### 스래싱(thrasing)
프로세스를 수행하는데 있어서, 페이지 부재가 계속적으로 발생되어 프로세스가 수행되는 시간보다 페이지 교체에 소비되는 시간이 더 많아지는 경우
![[운영체제 4-20240417212436350.webp|550]]

**스래싱을 방지하기 위하여 한 프로세스가 효율적인 수행을 위하여 제공 받아야 할 페이지 프레임의 수를 알아야 함**

##### 구역성
- ‘프로세스가 기억장치 내의 모든 정보를 균일하게 참조하는 것이 아니라 **국부적인 부분만을 집중적으로 참조한다**’는 것을 의미
- 이러한 구역성을 통하여 페이지 프레임의 수를 예측 가능함
##### 시간 구역성(temporal locality)
- 최근에 참조된 기억장소가 가까운 장래에도 계속 참조될 가능성이 높음을 의미함
- 예 : 순환(looping), 서브루틴, 스택, 카운팅(counting)과 집계(totaling)에 사용되는 변수
##### ▪ 공간 구역성(spatial locality)
- 하나의 기억장소가 참조되면 그 근처의 기억장소가 계속 참조되는 경향이 있음을 의미함
- Ex : **배열 수행**, 순차 코드의 실행(sequential code execution), 프로그래머들이 관련된 변수를 근처에 선언하는 경향이 있음

### 작업세트 (working set)
- **프로세스에 의해 자주 참조되는 페이지들의 집합체를 의미**
- 수행 중인 프로세스가 주기억장치 내에 작업세트를 잘 유지하고 있다면,  효율적으로 수행됨
### 페이지 부재율
- **주기억장치에 프로세스가 수행에 필요로 하는 페이지가 없는 비율**
- 페이지 부재율이 높으면, 그 프로세스가 더 많은 페이지 프레임을 필요로 함
- 페이지 부재율이 낮으면, 그 프로세스가 너무 많은 페이지 프레임을 가지고 있음
- **페이지 부재율의 상한과 하한을 이용하여 페이지 프레임을 동적으로 변경함**
![[운영체제 4-20240417212720696.webp|550]]
---
## 요약
##### 가상메모리
- 주기억장치보다 크기가 큰 프로세스 수행 가능
- 동적 주소 변환 (가상 기억 장치 -> 주기억장치), 블록 단위로 매핑(사상)
##### **가상 메모리와 실제 메모리 사이의 동적 주소 변환 구현 방법**
- 블럭의 크기가 고정된 페이징 기법
- 블럭의 크기가 가변적인 세그먼테이션 기법
- 세그면테이션과 페이징을 혼용한 기법
##### 페이지 교체 알고리즘
- 가장 오랫동안 주기억 장치에 있었던 페이지를 교체 (FIFO)
- 가장 오랫동안 사용되지 않을 페이지를 교체 (최적 교체)
- 가장 오래전에 사용되었던 페이지를 교체 (LRU)
- 참조 비트를 이용하여 FIFO 방법을 개선 (2차 기회 : second chance) 
- 가장 적게 사용되거나 집중적이 아닌 페이지를 교체 (LFU)
##### 스레싱(thrasing)
- 계속적으로 페이지 부재가 발생하여 프로세스의 처리 시간보다 페이지 교체
시간이 많아지는 현상
##### 작업세트 (working set)
- 프로세스가 효율적으로 실행되기 위해 주기억장치 내에 있어야 하는,  프로세스에 의해 자주 참조되는 페이지들의 집합
