### 메모리 주소 변환
##### 프로세스 제어블록
모든 프로세스는 실행을 위해 CPU가 필요
하지만 CPU 자원은 한정
- 프로세스들은 돌아가며 한정된 시간만큼 CPU 이용
	- 자신의 차례에 정해진 시간만큼 CPU 이용
	- 타이머 인터럽트가 발생하면 차례 양보	
- 빠르게 번갈아 수행되는 프로세스 관리
	- 이를 위해 사용하는 자료구조 - **프로세스 제어블록(PCB)**
		- **프로세스 관련 정보를 저장하는 자료 구조**
		- 상품에 달린 태그와 같은 정보
		- **프로세스 생성 시 커널 영역에 생성, 종료 시 폐기**

##### 프로세스 제어블록(PCB)에 담기는 대표적인 정보
- 프로세스 ID (= PID)
- 레지스터 값
- 프로세스 상태
- CPU 스케줄링 정보
- 메모리 정보
- 사용한 파일과 입출력장치 정보

##### 문맥 교환(context switch)
- 한 프로세스에서 다른 프로세스로 **실행순서**가 넘어가면?
	- 기존에 실행되던 프로세스 A는 지금까지의 **중간 정보**를 백업
		- 프로그램 카운터 등 각종 레지스터 값, 메모리 정보, 열었던 파일, 사용한 입출력장치 등
		- 이러한 중간정보 == **문맥**
		- 다음 차례가 왔을 때 실행을 재개하기 위한 정보
		- **실행 문맥을 백업해두면 해당 프로세스의 실행을 재개할 수 있다.**
	- 뒤어어 실행할 프로세스 B의 문맥을 복구
		- 자연스럽게 실행 중인 프로세스가 바뀜
- 이처럼 **기존의 실행 중인 프로세스 문맥을 백업하고 새로운 프로세스 실행을 위해 문맥을 복구하는 과정을 문맥교환**이라고 한다.
	- 여러 프로세스가 끊임없이 빠르게 번갈아가며 실행되는 원리

##### 프로세스 메모리 영역
크게 코드 영역(= 텍스트 영역), 데이터 영역, 힙 영억, 스택 영역
### 프로세스 상태
##### 생성 상태
- 이제 막 메모리에 적재되어 PCB를 할당 받은상태
- 준비가 완료되었다면 준비상태로
##### 준비 상태
- 당장이라도  CPU를 항당 받아 실행할 수 있지만, 자신의 차례가 아니기에 기다리는 상태
- 자신의 차례가 된다면 실행상태로 ( = 디스패치)
##### 실행 상태
- CPU를 할당받아 실행중인 상태
- 할당된 시간 모두 사용 시(타이머 인터럽트 발생 시) 준비 상태로 
- 실행 도중 입출력 장치를 사용하면 입출력 작업이 끝날 때까지 대기 상태로
##### 대기 상태
- 프로세스가 실행 도중 입출력장치를 사용하는 경우
- 입출력 작업은 CPU에 비해 느리기에 이 경우 대기 상태로 접어듬
- 입출력 작업이 끝나면(입출력 완료 인터럽트 받으면) 준비 상태로
##### 종료 상태
- 프로세스가 종료된 상태
- PCB 프로세스의 메모리 영역 관리
---
### 프로세스 스케줄링
**운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것**
##### 선점형과 비선점형 스케줄링
- 현재 CPU를 사용중인 **프로세스로부터 CPU자원을 빼앗아 다른 프로세스에 할당**
- 현재 CPU를 사용**중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기**
###### 선점형 스케줄링
장점
- 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다.
단점
- 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다.
###### 비선점형 스케줄링
장점
- 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다.
단점
- 모든 프로세스가 골고루 자원을 이용하기 어렵다.
##### 프로세스 스케줄링 알고리즘
- **선입 선처리 스케줄링 - FCFS**
- **최단 작업 우선 스케줄링 - SJF**
- 라운드 로빈 스케줄링 
- **최소 잔여 시간 우선 스케줄링 - SRT**
- 우선순위 스케줄링
- 다단계 큐 스케줄링
- 다단계 피드백 큐 스케줄링

###### 선입 선처리 스케줄링 FCFS
단순히 **준비 큐에 삽입된 순서대로** 처리하는 비선점 스케줄링
먼저 CPU를 요청한 프로세스로부터 CPU할당

단점
- **프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용 (=호위 효과)**
###### 최단 작업 우선 스케줄링 SJF
호위 효과를 방지하려면 
**CPU 사용이 긴 프로세스는 나중에 실행, CPU 사용 시간이 짧은 프로세스는 먼저 실행**
**CPU 사용 시간이 가장 짧은 프로세스부터 처리하는 스케줄링 방식**

###### 최소 잔여 시간 우선 스케줄링 SRT
최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
최단 작업 우선 스케줄링 : 작업 시간이 짧은 프로세스부터 처리하는 스케줄링 알고리즘
라운드 로빈 스케줄링 : 정해진 타임 슬라이스만큼 돌아가며 사용하는 스케줄링 알고리즘
- **정해진 시간만큼 CPU를 이용하되**, 다음으로 CPU를 사용할 프로세스로는 남은 **작업 시간이 가장 적은 프로세스** 선택

