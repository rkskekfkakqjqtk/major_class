### 객체 포인터
- C 언어의 포인터와 동일
- 객체의 주소 값을 가지는 변수
### 포인터로 멤버를 접근할 때
- 도트 연산자가 아닌 화살표 연산자 (->) 를 사용
- 객체포인터->멤버
### 객체의 주소
- 객체의 주소를 얻기 위해서는 & 연산자를 사용
---
### 객체 배열 선언
##### 기본 타입 배열 선언과 형식 동일
- `int n[3];` //정수형 배열 선언
- `Circle c[3];` // Circle 타입 배열 선언
##### 배열의 각 원소 객체마다 생성자 실행
- `c[0]`의 생성자, `c[1]`의 생성자, `c[2]`의 생성자 실행
- **매개 변수 없는 생성자 호출**
##### 매개 변수 있는 생성자를 호출할 수 없음
- `Cricle circleArray[3](5);` // 오류
### 배열 소멸
배열의 각 객체마다 소멸자 호출. 반대순으로 소멸
- `c[2]`의 소멸자, `c[1]`의 소멸자, `c[0]`의 소멸자 실행
---
### 객체 배열 초기화 방법
- 배열의 각 원소 객체당 생성자 지정하는 방법
`Circle circleArray[3] = { Circle(10), Circle(20), Circle( ) };`
- `circleArray[0]` 객체가 생성될 때, 생성자 `Cricle(10)` 호출
- `circleArray[1]` 객체가 생성될 때, 생성자 `Cricle(20)` 호출
- `circleArray[2]` 객체가 생성될 때, 생성자 `Cricle( )` 호출
### 초기화 문법
`class_name obj[2] = { class_name(num1), class_name(num2) }`
축약형 : `class_name obj[2] = { num1, num2 }`
생성자 함수의 인수가 하나일때는 축약형을 사용할 수 있으나, 두개 이상일때는 초기화 형식을 사용하여야 한다.

---
### 정적 할당
변수 선언을 통해 필요한 메모리 할당
- 많은 양의 메모리는 배열 선언을 통해 할당
### 동적 할당
필요한 양이 예측되지 않는 경우. 
프로그램을 작성시 할당 받을 수 있음
실행 중에 운영체제로부터 할당 받음
- 힙(heap)으로 부터 할당
	- 힙은 운영체제가 소유하고 관리하는 메모리. 모든 프로세스가 공유할 수 있는 메모리
---
###### C 언어의 동적 메모리 할당/반환
- malloc / free() 라이브러리 함수 사용
---
###### C++의 동적 메모리 할당/반환
- new 연산자
	- 기본 타입 메모리 할당, 배열 할당, 객체 할당, 객체 배열 할당
	- 객체의 동적 생성 - 힙 메모리로부터 객체를 위한 메모리 할당 요청
	- 객체 할당 시 **생성자 호출**
- delete 연산자
	- new로 할당 받은 메모리 반환
	- 객체의 동적 소멸 - 소멸자 호출 뒤 객체를 힙에 반환
---
### new 와 delete 사용
- C ++ 에서는 new를 사용하여 메모리를 할당하고 delete를 사용해 할당된 메모리를 해제한다.
- new/delete 연산자의 사용 형식
	`데이터타입 *포인터변수 = new 데이터 타입;`
	`delete 포인터변수;`
- 요구한 메모리가 충분하지 않으면 new는 null 포인터를 반환
---
### new 와 delete 가 malloc 과 free 보다 이점
- 메모리를 자동으로 할당 (sizeof 연산자 불필요)
- 지정된 형의 포인터를 자동으로 반환 (type cast 연산자 불필요)
- new와 delete는 중복이 가능(자신만의 할당 시스템을 쉽게 구현)
- 동적으로 할당된 객체를 초기화 시킬 수 있다
- 헤더파일(malloc.h or stdlib.h)이 필요 없다
---
###### 적절치 못한 포인터로 delete하면 실행 시 오류 발생!!
- 동적으로 할당 받지 않는 메모리 반환 - 오류
```ad-error
~~~C++
int n;
int *p = $n;
delete p; //실행 시 오류
// 포인터 p가 가리키는 메모리는 동적으로 할당 받은 것이 아님
```
```ad-error
~~~C++
int *p = new int;
delete p; // 정상적인 메모리 반환
delete p; // 실행 시 오류. 이미 반환한 메모리를 중복 반환할 수 없음
```
---
### 배열의 동적 할당 및 반환
동적으로 할당된 배열 사용 형식
`데이터타입 *포인터변수 = new 데이터타입 [배열의 크기];`
`delete [] 포인터변수; // 배열 반환`

---
### 동적 할당 메모리 초기화
###### 초기화 사용 형식
`데이터타입 *포인터변수 = new 데이터타입(초기값);`
###### 초기화 사용 예
`int *plnt = new int(20);` // 20으로 초기화된 int 타입 할당
`char *pChar = new char('a');` // 'a'로 초기화된 char 타입 할당
###### 배열은 동적 할당 시 초기화 불가능
`int *pArray = new int [10](20); ` // 구문 오류. 컴파일 오류 발생
`int *pArray = new int(20)[10]; ` // 구문 오류. 컴파일 오류 발생

---
### 배열을 delete 할 때 주의사항
delete 연산자에 `[]`생략하는 경우
- 컴파일 오류는 아니지만 비정상적인 반환
```ad-error
~~~C++
int *p = new int [10];
delete p; // 비정상 반환. delete [] p;로 하여야 함.

int *q = new int;
delete [] q; // 비정상 반환. delete q;로 하여야 함.
```
---
### 객체의 동적 생성 및 반환
```ad-note
title: 객체의 동적 생성 사용 형식
~~~C++
클래스이름 *포인터변수 = new 클래스이름;
클래스이름 *포인터변수 = new 클래스이름(생성자매개변수리스트);
delete 포인터변수;
```
---
### 객체 배열의 동적 생성 및 반환
```ad-note
title: 객체 배열 동적 생성 사용 형식
~~~C++
클래스이름 *포인터변수 = new 클래스이름 [배열 크기];
delete [ ] 포인터변수; // 포인터변수가 가리키는 객체 배열을 반환
```
---
### 객체 배열의 사용
동적으로 생성된 배열도 보통 배열처럼 사용
```ad-note
~~~C++
Circle *pArray = new Circle[3]; // 3개의 Circle 객체 배열의 동적 생성

pArray[0].setRadius(10); // 배열의 첫 번째 객체의 setRadius() 멤버 함수 호출
pArray[1].setRadius(20); // 배열의 두 번째 객체의 setRadius() 멤버 함수 호출
pArray[2].setRadius(30); // 배열의 세 번째 객체의 setRadius() 멤버 함수 호출

for(int i=0; i<3; i++) 
{
	cout << pArray[i].getArea(); // 배열의 i 번째 객체의 getArea() 멤버 함수 호출
}
```

포인터로 배열 접근
```ad-note
~~~C++
pArray->setRadius(10);
(pArray+1)->setRadius(20);
(pArray+2)->setRadius(30);

for(int i=0; i<3; i++) 
{
	(pArray+i)->getArea();
}
```
---
### 배열의 반환과 소멸자
배열 delete 사용 형식
`delete [ ] 포인터변수; ` // 포인터변수가 가리키는 객체 배열을 반환

배열 소멸
`delete [] pArray;`
- pArray`[2]` 객체의 소멸자 실행(1)
- pArray`[1]` 객체의 소멸자 실행(2)
- pArray`[0]` 객체의 소멸자 실행(3)
	- 각 원소 객체의 소멸자 별도 실행. 생성의 반대순
---
### 동적 메모리 할당과 메모리 누수
![[7.  객체의 포인터, 배열, 동적 생성-20240419220032052.webp]]
![[7.  객체의 포인터, 배열, 동적 생성-20240419220036076.webp]]
**※ 프로그램이 종료되면, 운영체제는 누수 메모리를 모두 힙에 반환**

---
### this 포인터
- this 는 어떤 멤버 함수가 호출되든지 간에 자동으로 멤버 함수에 전달 되는 포인터
- this 포인터는 호출한 객체를 가리키는 포인터
- 개발자가 선언하는 변수가 아니고, 컴파일러가 선언한 변수
	- this 포인터에는 멤버 함수를 호출할 때에 함수에 넘겨지는 묵시의 인수로 객체의 주소가 들어있다.
---
### this 포인터 예
```C++
class person
{
	char name[12];
	int age
public :
	void print( ) { cout << name << “ “<<age;}
};
.....
person ob;
ob.print( );
```
함수 print()는 호출한 객체 ob에 대한 포인터를 자동으로 전달받는다. 
이 포인터를 this 라고 함.

- 위의 예시에서 this->radius 라고 쓰는 대신 radius 라고 써도 완전히 동일
- 뒤의 것은 앞의 축약형
- 축약형이 더 쉽기 때문에 멤버를 접근하기 위해 this 포인터를 거의 사용하지 않지만 의미하는 바를 이해하는 것이 중요
- this 포인터는 연산자 중복과 같은 몇가지 경우에만 사용됨
---
### this 포인터가 필요한 경우
매개변수의 이름과 멤버 변수의 이름이 같은 경우
![[7.  객체의 포인터, 배열, 동적 생성-20240419220944411.webp]]
맴버 함수가 객체 자신의 주소를 리턴할때
- 연산자 중복 시에 **매우 필요**
![[7.  객체의 포인터, 배열, 동적 생성-20240419221004596.webp|255]]
---
### this  포인터의 제약 사항
맴버 함수가 아닌 함수에서 this 사용 불가
- 객체와의 관련성이 없기 때문
- 프렌드 함수는 this 포인터를 갖고 있지 않다
static 멤버 함수에서 this 사용 불가
- 객체가 생기기 전에 static 함수 호출이 있을 수 있기 때문에
---
### this 포인터의 실체
![[7.  객체의 포인터, 배열, 동적 생성-20240419221121311.webp]]

---
### string 클래스를 이용한 문자열
- C++ 문자열
	- C- 스트링
	- C++ string 클래스의 객체
- string 클래스
	- C++ 표준 라이브러리
	- `<string>` 헤더 파일을 include
```C++
#include <string>
using namespace std;
```
- 가변 크기 문자열
```C++
string str = "I love "; // str은 'I', ' ', 'l', 'o', 'v', 'e', ' '의 7개 문자로 구성
str.append("C++."); // str은 "I love C++."이 된다. 11개의 문자
```
- 다양한 문자열 연산을 실행하는 연산자와 멤버 함수 포함
	- 문자열 복사, 문자열 비교, 문자열 길이 등
- 문자열, 스트링, 문자열 객체, string 객체 등으로 혼용하여 사용
---
### string 객체 생성
- 생성자를 사용하여 다양하게 문자열 생성
- 문자열 크기에는 제한이 없음
```C++
string str; // 빈 문자열을 가진 스트링 객체
string address(“서울시 성북구 삼선동 389“); // 문자열 리터럴로 초기화
string copyAddress(address); // address를 복사한 copyAddress 생성

// C-스트링(char [] 배열)으로부터 스트링 객체 생성
char text[] = {'L', 'o', 'v', 'e', ' ', 'C', '+', '+', '\0'}; // C-스트링
string title(text); // “Love C++" 문자열을 가진 title 생성
```
---
### string 객체의 동적 생성
new/delete를 이용하여 문자열을 동적 생성
```C++
string *p = new string("C++"); // 스트링 객체 동적 생성

cout << *p; // "C++" 출력
p->append(" Great!!"); // p가 가리키는 스트링이 "C++ Great!!"이 됨
cout << *p; // "C++ Great!!" 출력

delete p; // 스트링 객체 반환
```