### 배열
- 동일 타입의 데이터를 하나의 단위로 다루기 위해 연결된 메모리
- C++는 C 언어의 배열 그대로 사용
- 서식
	- 1차원의 경우
		- 자료형     배열명 `[자료의 개수]`
		- **Ex.** float `a[10]`;
	- 2차원의 경우
		- 자료형     배열명`[행 개수][열 개수]`
		- **Ex.** `float a[10][10]`
### 배열의 구조와 개념
- 배열명은 변수명을 작성하는 규칙과 동일
- 자료의 개수를 첨자라 하며 총 자료의 개수를 의미
- **배열의 각각의 요소는 다음과 같은 명칭이 부여된다 (첨자 번호는 0번 부터 시작된다)**
	- **Ex.** `int array[5];`
![[5. 배열, 포인터, 함수-20240408202625019.webp]]
- 각각의 배열 요소는 독립적인 변수처럼 사용
``` C++
int box[10];
box[0] = 100;   box[1] = 2;
box[3] = box[0] + box[1];
box[box[1]] = 500;
```
- **배열명**은 그 배열의 **시작 주소**를 가리키는 포인터(번지) 상수이다.
- **배열 선언시 배열의 요소 x 자료형의 크기 만큼 메모리가 할당된다.**
### 배열의 초기화
- 서식
	- 자료형 배열명`[숫자]` = {제 0 요소의 초기값, ... 마지막 요소의 초기값}
	- **Ex.** `float a[5] = {3.5, 4.5, 2.2, 3.2, 4.5};`
- 배열의 원소 수보다 초기값의 개수가 적은 경우
	- **나머지는 0으로 초기화 된다.**
- 배열의 원소 수보다 초기값의 개수가 많은 경우
	- **오류(error) 처리 된다.**
- 배열의 초기화에 빈 괄호 (`[]`)를 사용하면 항목 수를 세어 그 크기의 배열을 만들어 준다.
	- **Ex.** int day`[]` = {31, 28, 31, 30, 30, 31};
- 초기화가 없다면 extern 과 static 배열은 0으로 초기화 된다. 그러나 auto 와 register 배열은 쓰레기(garbage)로 채워진다.
	- Ex. 
```C++ 
int fuzzy[2]; // auto array
static int wuzzy[2]; // static array
cout << fuzzy[1] << " "<< wuzzy[1];
``` 
- 배열의 선언 및 활용 예
``` C++
#include <iostream>
using namespace std;

int main() {
	int n[10]; // 정수 10개짜리 빈 메모리 공간
	double d[] = { 0.1,0.2,0.5,3.9 }; // 배열 d에 0.1,0.2,0.5,3.9로 초기화

	int i;
	for (i = 0; i < 10; i++) n[i] = i * 2; // 2의 배수로 n에 값을 채움
	for (i = 0; i < 10; i++) cout << n[i] << ' '; //배열 n 출력
	cout << "\n"; //한 줄 띈다.

	double sum = 0; //C++ 에서는 필요할 때 변수를 아무곳이나 선언가능
	for (i = 0; i < 4; i++) {
		sum += d[i];
	}
	cout << "배열 d의 합은 " << sum; // 배열 d의 합 출력
}
```
### 함수란?
- 특정한 작업을 수행하도록 설계된 독립적인 프로그램
- **매개변수**를 통해 데이터를 전달받아 처리한 후, 결과를 반환하는 코드 블록
- C++ 는 C 언어의 함수 기법 그대로 계승
- 서식
``` C++
결과의 형명 함수이름(매개변수 리스트)
{
	계산하는 프로그램 코드들;
	return 반환 값;
}

```
- 함수의 예
```C++
#include <iostream>
using namespace std;

int func(int i)
{
	i = 5;
	cout << "\n i 에 5 를 대입 \n";
	return 2 * i + 3;
}
void main()
{
	int i, j;
	i = 3;
	cout << "i = " << i;
	j = func(i);
	cout << "i = " << i << '\n';
	cout << "j = " << j << '\n';
}
```
### 함수 작성과 호출시 주의할 점
![[5. 배열, 포인터, 함수-20240408212121672.webp]]
- 함수 원형, 함수 프로토타입이란?
	- 변수 선언처럼, 함수의 형식만 선언한 것
	- 세미콜론( ; )으로 끝맺음
	- Ex. int adder(int a, int b); // adder() 함수의 원형
- 함수의 원형을 선언하는 이유
	- 함수 이름, 매개 변수 타입과 개수, 리턴 타입을 컴파일러에게 알려주어 함수 호출 문장이 정확한지 판단하게 도움
![[5. 배열, 포인터, 함수-20240408212330511.webp]]
### 함수의 매개 변수로 배열 전달
```
int addArray(int a[], int size) { //배열을 매개 변수로 가진 함수
...            ----> int *a
}
```
--- 
```C++
int n[5] = {1,2,3,4,5};
int s = addArray(n, 5) // 배열 n을 매개 변수로 전달
int m[3] = {1,2,3};
int t = addArray(m, 3) // 배열 m을 매개 변수로 전달
```
![[5. 배열, 포인터, 함수-20240408213503427.webp|500]]

---
### 함수의 인수 인도 방법
- **Call by value(값 인도) = 값 복사**
![[5. 배열, 포인터, 함수-20240408213556248.webp|400]]
- Call by reference(주소 인도) = 주소 전달
![[5. 배열, 포인터, 함수-20240408213631142.webp|400]]
---
### 함수의 인수 인도 방법의 예
![[5. 배열, 포인터, 함수-20240408213732551.webp|500]]
### 포인터의 개념
- 포인터란 번지에 대한 기호화된 표현
- **포인터 변수**란 번지 값을 지정할 수 있는 **변수**를 의미하며 다음과 같이 선언한다.
```C++
char *buf
int * buf1
float *buf2
```
- 포인터 변수의 용도는 **주소(포인터)를 이용**하여 메모리에 직접 값을 쓰거나 메모리로 부터 **값을 읽어올 수 있음**
### 포인터의 연산자
- & 연산자
	- 변수명 앞에 붙으며, 그 변수의 번지 값을 나타냄
- * 연산자
	- 포인터 상수나 포인터 변수 앞에 사용되며, 그 포인터(번지)에 위치한 변수 값을 가리킬 때 사용
	- Ex.  x 가 변수명일 때
		 &x 는 x 에 할당되어 있는 번지를 나타내고
		 a가 번지일 때
		  `* a` 는 a 번지의 내용을 나타낸다.
### 일반 변수와 메모리 주소
```C++
int n;
n = 3;
```
- 변수 n 은 정수를 저장할 메모리 공간에 대한 이름, 이곳에 3을 저장
- 값이 3이 메모리 몇 번지에 기록되는지 알 수 없음
	- 프로그램이 실행을 시작할 때, 변수 n의 절대 메모리 주소가 정해짐
- 주소를 사용하는 것보다 이름 **n을 사용하는 것이 용이함**
### 포인터 변수
- 포인터. 즉 **주소**를 저장하는 변수
```C++
int *p; ---> 정수를 저장하는 메모리에 대한 포인터 변수 p 선언
p = &n; ---> p에 n의 주소를 저장
```
![[5. 배열, 포인터, 함수-20240408214731743.webp|400]]

---
### 포인터 선언 및 활용
```C++
#include <iostream>
using namespace std;

int main() {
	int n = 10, m;
	char c = 'A';
	double d;

	int* p = &n; //p는 n의 주소값을 가짐
	char* q = &c; // q는 c의 주소값을 가짐
	double* r = &d; // r은 d의 주소값을 가짐

	*p = 25; // n에 25가 저장됨
	*q = 'A'; // c에 문자 'A'가 저장됨
	*r = 3.14; // d에 3.14가 저장됨
	m = *p + 10; //p가 가리키는 값(n 변수값) + 10을 m에 저장

	cout << n << ' ' << *p << "\n"; // 둘 다 25가 출력됨
	cout << c << ' ' << *q << "\n"; // 둘 다 'A'가 출력됨
	cout << d << ' ' << *r << "\n"; // 둘 다 3.14가 출력됨
	cout << m << "\n"; // m값 35 출력
}
```
![[5. 배열, 포인터, 함수-20240408215315016.webp|400]]

---
### **배열과 포인터의 관계**
- 배열명 a 는 배열 메모리의 **시작 주소로 포인터** 이다.
- 그 값은 `&a[0]` 즉 배열의 선두번지와 같다.
- 배열과 포인터는 선언과 저장 방식은 다르지만, 사용시에는 같은 개념으로 사용된다.
```C++
int array[5]; 일때
array[0] ---> *(array + 0) ---> *array
array[1] ---> *(array + 1)
array[4] ---> *(array + 4) 와 동일한 표기법이다
```
![[5. 배열, 포인터, 함수-20240408215552920.webp|500]]
- `*연산자`는 `+연산자` 보다 **우선순위**를 갖는다.
**Ex.**
```C++
int data[4]; 일때
*(data + 2) ---> data[2]
*data + 2 ---> data[0] + 2
의 차이점을 알아야 한다
```
