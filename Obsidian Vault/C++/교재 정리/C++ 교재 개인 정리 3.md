### 객체

캡슐화
- 객체의 구성요소들을 캡슐로 싸서 보호하고 볼 수 없게 하는 객체의 본질적인 특징
---
### C++ 객체는 멤버 함수와 멤버 변수로 구성된다
객체는 자신만의 고유한 상태(state)와 행동(behavior)으로 구성된다.
C++에서 객체는 **멤버 변수**와 **멤버 함수**로 구성

---
### C++ 클래스와 C++ 객체
##### 클래스 Class 
- **객체(object)** 를 정의하는 틀 혹은 설계도
- 클래스에 **멤버 변수**와 **멤버 함수**를 선언함
---
객체는 클래스라는 틀에서 찍어내어, 멤버 변수 메모리와 멤버 함수 코드를 실제 가지고 C++ 프로그램이 실행되는 동안 실존하는 **실체** 혹은 **인스턴스(instance)** 이다.
컴파일이 끝나면 사라지지만, 프로그램은 **실행 중에 객체를 생성**하여 멤버 변수에 값을 저장하기도 하고 멤버 함수 코드를 실행하기도 한다.
- 객체들은 얼마든지 생성될 수 있다. 이때 각 객체들은 **상호 별도 공간에 생성**된다.
---
### C++ 클래스 만들기
class 키워드를 이용하여 클래스를 선언
클래스는 구조체(struct)와 같이 개발자가 정의하는 새로운 데이터 타입
- 클래스는 일반적으로 **클래스 선언부**과 **클래스 구현부**로 나누어 작성
- 클래스 선언부는 class 키워드로 클래스의 모양을 선언. 클래스 구현부는 클래스의 멤버 함수들을 구현.
```cpp
// 클래스 선언부
class Circle
{
public:
	int radius; // 멤버 변수
	double getArea(); // 멤버 함수
};

// 클래스 구현부
double Circle::getArea()
{
	return 3.14 * radius * radius;
}
```
---
##### 클래스 선언부
클래스는 **class** 키워드와 **클래스 이름**으로 선언
```cpp
class Circle // Circle 이름의 클래스 선언
{
	...
}; // 반드시 세미콜론( ; )으로 종료
```
##### 클래스 멤버
```cpp
class Circle
public:
	int radius = 5; // 클래스 선언부에서 멤버 변수를 초기화할 수 있음
```
맴버함수는 원형 형태로 선언되며, 리턴 타입, 매개 변수 리스트 등이 모두 선언되어야 한다.
```cpp
double getArea();
```
##### 접근 지정자, public
클래스의 일부 맴버들을 다른 클래스와의 통신을 위해 외부에 공개하기도 한다. 맴버를 외부에 공개하려면, 다음과 같이 **public 접근 지정자**로 선언한다.
```cpp
class Cricle
{
public: // 이하의 모든 맴버는 다른 접근 지정자가 선언될 때까지 public 접근 지정
	...
}
```
접근 지정자는 **public, private, protect** 3가지 종류가 있다.
- public - 클래스 외부로부터의 접근을 허용
- private - 외부에서 접근 불가. 접근 지정의 디폴트값
- protected - 상속 관계
---
### 클래스 구현부
클래스 구현부에서는 클래스 선언부에 선언된 멤버 함수의 코드를 구현
```cpp
double Circle::getArea()
{
	return 3.14 * radius * radius;
}
```
2개의 콜론으로 만들어진 **범위 지정 연산자( : : )** 를 사용하여 클래스 이름과 함께 멤버 함수를 기술
이것은 같은 이름의 함수가 다른 클래스에 존재할 수 있기 때문
- 클래스 선언과 구현의 분리는 왜 할까?
	- 클래스의 재사용을 위해서
---
### 객체 생성과 활용 예제
```cpp
#include <iostream>
using namespace std;

// Circle 선언부
class Circle
{
public:
	int radius; // 멤버 변수
	double getArea(); // 멤버 함수
};

// Circle 구현부
double Circle::getArea()
{
	return 3.14 * radius * radius;
}

int main()
{
	Circle donut;
	donut.radius = 1; //donut 객체의 반지름을 1로 설정
	double area = donut.getArea(); // donut 객체의 면적 알아내기
	cout << "donut 면적은 " << area << endl;

	Circle pizza;
	pizza.radius = 30; //pizza 객체의 반지름을 30으로 설정
	area = pizza.getArea(); //pizza 객체의 면적 알아내기
	cout << "pizza 면적은 " << area << endl;
}
```
---
### 객체 생성과 객체 이름
위의 예제를 보면서 객체 생성과 겍체 이름에 대해 구체적으로 알아보자.
```cpp
int money; // int 타입의 변수 money 생성

Circle donut; // Circle 클래스의 객체 생성. 객체 이름은 donut
Circle pizza; // Circle 클래스의 객체 생성. 객체 이름은 pizza
```
### 객체의 멤버 접근
- 객체의 멤버에 접근하기 위해서는 다음과 같이 객체 이름 뒤에 **.(점)** 을 찍고 그 뒤에 멤버를 쓴다
	`객체이름. 멤버`

donut의 getArea( ) 멤버 함수를 호출하는 코드이다.
```cpp
double area = donut.getArea( ); // donut 객체의 면적 알아내기
```
코드의 실행 결과 getArea()가 리턴한 값이 area에 저장된다. donut 객체는 main( )에 의해 생성되었으므로 area 변수와 함께 main( )의 스택에 존재된다.

---
### 생성자
```cpp
// 2개의 생성자 함수 선언
class Circle
{
	.....
	Circle( ); // 클래스 이름과 동일
	Circle(int r); // 리턴 타입 명기하지 않음
	....................
};
// 생성자 함수 구현
Circle::Circle( ) // 매개 변수 없는 생성자
{
	..................
}
Circle::Circle(int r) // 매개 변수를 가진 생성자
{
	..................
}
```
생성자의 목적은 **객체가 생성될 때 필요한 초기 작업을 위함**이다
- 멤버 변수의 값을 특정 값으로 설정하거나, 메모리를 동적 할당 받거나, 파일을 열거나, 네트워크를 연결하는 등 객체를 사용하기 전에 필요한 조치를 할 수 있도록 하기 위함이다

생성자 함수는 **오직 한 번만 실행**된다.
- 생성자 함수는 각 객체마다 객체가 생성되는 시점에 오직 한 번만 자동으로 실행된다.

생성자 함수의 **이름은 클래스 이름과 동일하게 작성**되어야 한다.
- 생성자 함수의 이름은 반드시 클래스 이름과 동일하게 작성되어야 한다. 이로인해 생성자는 다른 멤버 함수와 쉽게 구분된다.

**생정자 함수의 원형에 리턴 타입을 선언하지 않는다**.
- 생성자는 함수이지만 리턴 타입을 선언해서는 안 된다. void 리턴 타입을 설정해서도 안된다. 
---
### 생성자는 중복 가능하다
```cpp
Circle( ); // 매개 변수 없는 생성자
Circle(int r); // 매개 변수 있는 생성자
```
--- 
### 생성자와 멤버 변수의 초기화
 **클래스 멤버 변수들은 자동으로 초기화되지 않기 때문에 생성자에서 초기화**한다. 
- 생성자 코드에서 멤버 변수 초기화
```cpp
class Point
{
	int x, y;
public:
	Point( );
	Point(int a, int b);
};
Point::Point( ){ x = 0; y = 0; }
Point::Point(int a, int b) { x = a; y = b; }
```
- 생성자 서두에 초깃값으로 초기화
```cpp
Point::Point( ) : x(0), y(0){ // 멤버 변수 x, y를 0으로 초기화
}
Point::Point(int a, int b) // 멤버 변수 x = a로, y = b로 초기화
	: x(a), y(b)  {	// 콜론 ( : ) 이하 부분을 다음 줄에 써도 됨
}
```
또는 다음과 같이 멤머 변수를 초기화해도 된다.
```cpp
Point::Point(int a)
	: x(a), y(b) {	// 멤버 변수 x = a, y = 0으로 초기화
}
Point::Point(int a)
	: x(100 + a), y(100){ // 멤버 변수 x = 100 + a, y = 100으로 초기화
	}
```
- 클래스 선언부에서 직접 초기화
맴버 변수는 C++11부터 다음과 같이 선언문에서 직접 초기화 할 수 있다
```cpp
class Point
{
	int x = 0, y = 0; // 클래스 선언부에서 x, y를 0으로 직접 초기화
	......
};
```
---
##### 생성자는 꼭 있어야 하는가?
객체가 생성될 때 반드시 생성자가 호출된다.
생성자가 없는 클래스에 대해서는 **컴파일러가 기본 생성자를 만들어 삽입하고 자신이 삽입한 기본 생성자를 호출**하도록 컴파일 한다.
##### 기본 생성자
클래스에 선언된 어떤 생성자도 없을 때 컴파일러가 자동으로 생성해주는 생성자로서 **디폴트 생성자**라고도 부르며, **매개 변수 없는 생성자**이다
```cpp
class Circle
{
	Circle( ); // 기본 생성자
}
```
---
###### 기본 생성자가 자동으로 생성되는 경우
- 생성자가 하나도 없는 클래스의 경우 컴파일러는 보이지 않게 기본 생성자를 삽입한다.
###### 기본 생성자가 자동으로 생성되지 않는 경우
- **생성자가 하나라도 선언된 클래스의 경우**, 컴파일러는 기본 생성자를 자동 삽입하지 않는다.

---
### 소멸자
객체가 소멸되면 객체 메모리는 시스템으로 반환된다. 또한 객체 생성 시 생성자 함수가 실행되는 것처럼 객체 소멸 시 소멸자 함수가 실행된다.
**소멸자**는 객체가 소멸되는 시점에서 자동으로 호출되는 **클래스의 멤버 함수**이다.
```cpp
class Circle
{
	Circle();
	Circle(int r);
	.....
	//소멸자 함수 선언
	~Circle();  // 리턴 타입도 없고 매개변수도없음. 소멸자는 오직 하나만 존재 
};
Circle::~Circle() // 소멸자 함수 구현
{
	......
}
```
---
### 소멸자의 특징
소멸자의 목적은 **객체가 사라질 때 필요한 마무리 작업을 위함**이다.
- 객체가 소멸할 때, 동적으로 할당받은 메모리를 객체가 사라지기 전에 필요한 조치를 하도록 위함이다.

소멸자의 이름은 클래스 이름 앞에 ~를 붙인다.
- Circle 클래스의 소멸자 이름은 ~Cirlce( )이며, 소멸자는 다음과 같이 작성한다.
```cpp
Circle::~Circle( ){ ... }
```

소멸자는 **리턴 타입이 없으며 어떤 값도 리턴해서는 안 된다**.
- 소멸자는 생성자와 같이 리턴 타입 없이 선언되며 어떤 값도 리턴해서는 안 된다.

소멸자는 오직 **한 개만 존재하며 매개 변수를 가지지 않는다**.
- 소멸자는 생성자와 달리 한 클래스에 한 개만 존재하며 매개 변수를 가지지 않는다.

소멸자가 선언되어 있지 않으면 **기본 소멸자가 자동으로 생성**된다.
- 생성자와 마찬가지로 소멸자가 없는 클래스는 컴파일러에 의해 자동으로 기본 소멸자가 주어진다. 아무 일도 하지 않고 단순 리턴하도록 만들어진다.
---
### 소멸자 실행
```cpp
int main( )
{
	Circle donut;
	Circle pizza(30);
	return 0;
}
```
main( )의 스택에 donut, pizza의 순서로 객체가 생성되며, return 0; 문이 실행되면 **생성된 반대순으로** pizza, donut 객체가 소멸된다. pizza 객체의 ~Circle( ) 소멸자와 donut 객체의 ~Circle( ) 소멸자가 각각 순서대로 실행한다.

### 생성자/소멸자 실행 순서
함수 내에서 선언된 객체를 **지역 객체**라고 부르고 함수 바깥에 선언된 객체를 **전역 객체**라고 부른다.
```cpp
class Circle
{
	...
};
Circle globalCircle; //전역 객체
void f( )
{
	Circle localCircle; // 지역 객체
}
```
지역 객체는 함수가 실행될 때 성상되고 함수고 종료할 때 소멸되지만, 전역 객체는 프로그램이 로딩될 때 생성되고 main( )이 종료한 뒤 프로그램 메모리가 사라질 때 소멸된다.
전역 객체나 지역 객체 모두 **생성된 순서의 반대순으로 소멸**된다.

---
### 접근 지정
##### 접근 지정자
객체 지향 언어에서는 객체를 캡슐화하고, 외부에서 접근 가능한 공개 멤버와 외부의 접근을 허용하지 않는 비공개 멤버를 구분한다. 
C++ 에는 다음 3가지 **멤버 접근 지정자**가 있다.
- **private** (비공개)
- **public** (공개)
- **protected** (보호)
- ---
멤버에 대한 접근 지정은 클래스 선언부에서 접근 지정자 다음에 콜론 ( : )을 찍고 멤버들을 선언하는 방식으로 이루어진다.
```cpp
class Sample{
private:
	// private 멤버 선언. 클래스 내의 멤버 함수만 접근 가능
public:
	// public 멤버 선언. 클래스 내외의 모든 함수에게 접근 허옹
protected:
	// protected 멤버 선언. 클래스 내의 멤버와 상속받은 파생 클래스에만 접근 허용
}
```
**private 멤버**
- private 접근 지정으로 선언된 멤버로서, **클래스 내의 멤버 함수들에게만 접근이 허용**된다.
**public 멤버**
- public 접근 지정으로 선언된 멤버로서, 클래스 내외를 막론하고 프로그램의 **모든 함수들에게 접근이 허용**된다.
**protected 멤버**
- protected 접근 지정으로 선언된 멤버로서, **클래스 내의 멤버 함수와 이 클래스를 상속받은 파생 클래스의 멤버 함수에게만 접근이 허용**된다.
---
##### 디폴트 접근 지정은 private
접근 지정을 하지 않은 경우에는 **디폴트 접근 지정 private으로 처리**된다.

---
### 멤버 보호와 생성자
맴버 변수는 private으로 지정하는 것이 바람직함
- 클래스의 멤버들은 클래스 외부에서 마음대로 접근할 수 있도록 허용해서는 안 되는 것이 기본.
생성자는 public 으로
- 생성자가 public 으로 선언되어 있지 않다면 다음 라인은 컴파일 오류가 발생한다.
```cpp
Circle circle; // Circle( ) 생성자를 호출하므로 Circle( )은 public이어야 함
```
---
### 인라인 함수
**함수 호출 오버헤드**
- 짧은 코드를 함수로 만들면 함수 호출의 오버헤드가 상대적으로 커서 프로그램 실행 시간이 길어지는 원인이 된다.
- 짧은 코드로 이루어진 이러한 함수에 대해 호출 오버헤드를 줄일 방법이 있으면 프로그램의 **실행 속도**를 **개선**할 수 있을 것이다.
```cpp
#include <iostream>
using namespace std;

int odd(int x)
{
	return (x % 2);
}

int main()
{
	int sum = 0;

	// 1에서 10000까지의 홀수의 합 계산
	for (int i = 1;i < 10000; i++)
	{
		if (odd(i))
			sum += i;
	}
	cout << sum;
}
```
- 10000번의 함수 호출. 호출에 따른 엄청난 오버헤드 시간이 소모됨.
- odd( ) 함수의 코드 x%2를 계산하는 시간보다 odd( ) 함수 호출에 따른 오버헤드가 더 크며, 루프를 돌게 되면 오버헤드는 가중된다.
---
### 인라인 함수
**인라인 함수**란 짧은 코드로 구성된 함수에 대해, 함수 호출 오버헤드로 인한 프로그램의 실행 속도 저하를 막기 위해 도입된 기능.
인라인 함수는 **inline 키워드**를 이용하여 다음과 같이 선언한다.
```cpp
inline int odd(int x){ // odd 함수를 인라인 함수로 선언
	return (x%2);
}
```
컴파일러는 인라인 함수를 호출하는 곳에 인라인 함수의 코드를 그대로 삽입하여 함수 호출이 일어나지 않게 한다. 이렇게 하면 함수 호출 오버헤드가 없어지기 때문에 **실행 속도가 빨라진다.**

---
### 인라인 함수의 장단점
C++에서는 멤버 변수의 값을 알아내고 멤버 변수에 값을 쓰는 이른바 **getter / setter** 라고 불리는 작은 멤버 함수들이 많이 존재하며, 이 멤버 함수들을 호출하는 코드역시 많이 존재.
작은 함수를 인라인으로 선언하면 **C++ 프로그램의 실행 속도를 향상 시킬 수 있다.**
그러나 인라인 함수를 호출하는 곳에 인라인 함수의 코드를 단순 삽입하므로, 호출하는 곳이 여러 군데 있으면 그 만큼 **전체 크기가 늘어나는 단점**이 있음.

---
### 인라인 함수의 제약 사항
컴파일러는 함수의 크기나 효율을 따져서 불필요한 경우, inline 선언을 무시할 수 있다.
- 재귀 함수, static 변수, 반복문, switch 문, goto 문 등을 가진 함수는 인라인 함수로 허용하지 않는다.
---
### 맴버 함수의 인라인 선언과 자동 인라인
생성자를 포함하여 클래스의 모든 멤버 함수가 인라인으로 선언될 수 있다.
맴버 함수의 크기가 작은 경우, **클래스의 선언부에 직접 구현**하여도 무방.
컴파일러는 클래스의 선언부에 구현된 멤버 함수들에 대해서 inline 선언이 없어도 **인라인 함수로 자동 처리**한다.
#p133

---
### C++ 구조체
C++ 에서는 C 언어와의 호환성을 위해 구조체를 지원한다.
C++ 구조체는 C 구조체에 기능을 확장하여 **클래스와 동일한 구조와 기능**을 가진다.
C++ 구조체는 **struct 키워드로 선언**하며, 멤버 변수와 멤버 함수를 가지고, 접근 지정도 해야한다.
```cpp
struct structName
	//디폴트 접근 지정은 public. public 속성의 멤버 변수나 멤버 함수 선언
{
private:
	// private 속성의 멤버 변수나 멤버 함수 선언
public:
	// public 속성의 멤버 변수나 멤버 함수 선언
protected:
	// protected 속성의 멤버 변수나 멤버 함수 선언
};
```
---
### C++ 구조체의 객체 생성
```cpp
structName stObj; // structName 타입의 구조체 객체 생성
struct structName stObj; // C++ 에서 컴파일 오류. struct 키워드 사용 불가
```
---
### 구조체와 클래스의 차이점
C++ 의 구조체는 클래스와 기능적으로 동일하다. 멤버 변수뿐 아니라 생성자와 소멸자를 비롯한 멤버함수를 가질 수 있으며, 다른 구조체나 클래스에게 상속 가능하고 다른 구조체나 클래스를 상속받을 수 있다.

클래스가 구조체와 오직 한 가지 다른 점은 클래스의 **디폴트 접근 지정**이 private인 반면, 구조체는 public이다

