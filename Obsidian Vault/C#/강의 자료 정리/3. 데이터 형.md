### C# 언어의 데이터 형의 종류
- **값형**(Value Type)
	- 값 자체를 갖는 데이터 형
	- 기본형, 열거형, 구조체
- **참조형**(reference type)
	- 메모리 위치에 대한 참조를 가진 데이터 형
	- 클래스형, 인터페이스형, 델리게이트형, 배열
#### C#에서 정의된 모든 데이터 형은 System 네임 스페이스에 정의 되어 있다.

---
### 값 형식과 참조 형식
- 값 형식: 변수가 값을 담는 데이터 형식
- 값 형식 변수는 스택에 할당되고 변수 생성 코드 범위를 벗어나면 해제됨
![[3. 데이터 형-20240405130744126.webp|600]]
---
- 참조 형식: 변수가 값 대신 값이 있는 곳의 위치를 담는 데이터 형시그로 가비지 컬렉터에 의해 해제됨.
- 참조 형식 변수는 에 데이터를 저장하고 스택에 힙의 메모리 주소를 할당한다.
![[3. 데이터 형-20240405130913116.webp|600]]
---
### 정의된 13가지 값 형(value type)
| C# 데이터 형    | 닷넷 프레임 워크 **CTS** |
| ----------- | ----------------- |
| **sbyte**   | System.Sbyte      |
| **short**   | System.Int16      |
| **int**     | System.Int32      |
| **long**    | System.Int64      |
| **byte**    | System.Byte       |
| **ushort**  | System.Uint16     |
| **uint**    | System.Uint32     |
| **ulong**   | System.Uint64     |
| **float**   | System.Single     |
| **double**  | System.Double     |
| **decimal** | System.Decimal    |
| **char**    | System.Char       |
| **bool**    | System.Boolean    |
### 정의된 2가지 참조형(reference type)
| C# 데이터 형   | 닷넷 프레임 워크 데이터 형 |
| ---------- | --------------- |
| **object** | System.Object   |
| **string** | System.String   |
### 공용 형식 시스템(CTS)
- C#의 모든 데이터 형식 체계는 사실 C#의 고유의 것이 아님
- .NET 프레임워크의 형식 체계의 표준인 공용 형식 시스템(Common Type System)을 따르고 있을 뿐임
- 공용 형식 시스템의 이름은 "모두가 함께 사용하는 데이터 형식 체게"라는 뜻. 즉, 공용 형식 시스템은 .NET 언어들이라면 반드시 따라야 하는 데이터형식 표준
- 마이크로소프트가 "공용"형식 시스템을 도입한 이유는 .NET 언어들끼리 서로 호환성을 갖도록 하기 위해서임
### 정수형
- 정수의 값을 갖는 데이터 형
![[3. 데이터 형-20240405132126559.webp|500]]
---
### 부호 있는 정수와 부호 없는 정수
- 부호 있는 정수: sbyt, short, int, long ...
- 부호 없는 정수: byte, ushort, uint, ulong ...
- C#에서는 "2의 보수법"을 이용하여 음수를 포현
	1. 먼저 수 부분 비트를 채운다
	2. 전체 비트를 반전시킨다
	3. 반전된 비트에 1을 더한다.
![[3. 데이터 형-20240405132354174.webp|400]]

### 실수형
| 유형     | 크기           | 범위                                             |
| ------ | ------------ | ---------------------------------------------- |
| float  | 32비트(7자리 표현) | 1.5 x 10<sup>-45</sup> ~ 3.4 x 10<sup>38</sup> |
| double | 64비트(16자리 표) | 5 x 10<sup>-324</sup> ~ 1.7 x 10<sup>308</sup> |
- double형이 float형보다 메모리를 두 배 사용하지만 그만큼 float에 비해 데이터 손실이 적기때문에 float 보다는 double 형을 사용하길 권장함
### decimal 형
| 유형      | 크기             | 범위                                             |
| ------- | -------------- | ---------------------------------------------- |
| decimal | 128비트(28자리 표현) | 1.0 x 10<sup>-28</sup> ~ 7.9 x 10<sup>28</sup> |
- 금융이나 회계 계산처럼 높은 정밀도를 요구
- 반올림 오차가 허용되지 않는 회계 계산에 적합
- decimal 변수에 데이터 값을 대입할 때는 숫자 맨 뒤에 알파벳 'M' 을 반드시 붙여줘야한다.
### 문자형
| 유형   | 크기   | 설명           |
| ---- | ---- | ------------ |
| char | 16비트 | 단일 유니코드를 나타냄 |
- 문자를 표현하는 데이터 형
- 문자형 변수에 문자 상수를 대입할 때는 작은 따옴표를 사용해야 한다.
- 유니코드 형태로 문자를 다룸
	- 유니코드는 16비트 크기로 영어뿐 아니라 전 세계의 문자를 표시하기 위한 코드 체계
### 논리형
| 유형   | 크기  | 설명              |
| ---- | --- | --------------- |
| bool | 8비트 | 참과 거짓을 저장할 수 있음 |
- 논리형은 가장 간단한 데이터 형으로 가질 수 있는 값은 **true** 또는 **false** 둘 중 하나이다.
- 주로 제어문이나 반복문에서 조건을 비교한 결과로서 반환되는 값이 논리형이다.
- C#에서는 0이 아닌 값이 true를 대신할 수 없음
---
### 숫자의 특정 데이터 형을 만드는 방법
- 숫자 끝에 형을 지정하는 문자를 붙인다.
- L: Long 형
- U: 부호 없는 숫자
- F: float 형
- D: double 형
- M: decimal 형
### object 형
- 모든 C# 데이터 형은 object형을 상속받은 것이기 때문에 모든 데이터 형을 대신하여 표현할 수 있다.
![[3. 데이터 형-20240405134150922.webp|500]]
- **Ex.**
	- `object obj1 = 1234;`
	- `object obj2 = "C# Programming";`
- **Boxing** 과 **Unboxing**
	- Boxing : 값 형식 데이터를 상자에 담아 힙에 올려놓고, 그 힙의 위치를 object 형식 변수가 가리키도록 하는 것
	- Unboxing : 힙 안에 올라가 있는 상자를 풀어 값 형식 데이터를 꺼내는 것
![[3. 데이터 형-20240405134411410.webp]]
### string 형
- 문자열을 다루는 데이터 형
- string형을 사용하는 예
	- `string s1 = "Programming";`
	- `string s2 = s1;`
	- `s1 = "C#";`
		- s1은 별도의 메모리를 할당 받기 때문에 s2값에 영향을 미치지 않는다.
		- s1은 c#을 s2는 Programming이라는 문자열을 갖는다.
- **문자열을 합치는 연산자는 + 연산자이다.**
- 문자열 분할하는 메서드
	- Split() : 지정된 문자를 기준으로 문자열을 분리한 후 분리한 문자열의 배열을 반환
	- Substring() : 현재 문자열의 지정된 위치에서 지정된 수 만큼의 새 문자열을 반환
```C#
string greeting = "Good Morning";

Console.WriteLine(greeting.Substring(0,7));
string[]arr = greeting.Spilt(" ", 2);
```
- 문자열 앞/뒤 공백 제거 메서드
	- Trim() : 문자열의 앞과 뒤에 존재하는 공백 제거
	- TrimStart() : 문자열의 앞에 존재하는 공백 제거
	- TrimEnd() : 문자열의 뒤에 존재하는 공백 제거
```C#
string a,b,c,d;
a = "    welcome    ";
b = a.Trim();
c = a.TrimStart();
d = a.TrimEnd();
```
### 자료형 크기
- sizeof 연산자를 사용하면 자료형의 크기를 출력할 수 있다.
- **Ex.**
	`Console.WriteLine($"int 자료형의 크기 : {sizeof(int)}");`
- **문자열 자료형은 가변적 크기를 제공**하기 때문에 sizeof 연산자를 사용할 수 없다.
### 형식 변환(Type Conversion)
- 변수를 다른 데이터 형식의 변수에 옮겨 담는 것
	- Boxing과 Unboxing도 값 형식과 참조 형식간의 형식 변환
- 형식 변환의 종류
	- 크기가 서로 다른 정수 형식 사이의 변환
	- 크기가 서로 다른 부동 소수점 형식 사이의 변환
	- 부호 있는 정수 형식과 부호 없는 정수 형식 사이의 변환
	- 부동 소수점 형식과 정수 형식 사이의 변환
	- 문자열과 숫자 사이의 변환
##### 1. 크기가 서로 다른 정수 형식 사이의 변환
- 작은 정수 형식 변수 데이터 -> 큰 정수 형식 변수
- 큰 정수 형식 변수 데이터 -> 작은 정수 형식 변수
	- -> Overflow 발생 가능성
	- Overflow가 발생해도 특별한 에러 메세지가 발생 안함
```C#
.int x = 128; // sbyte의 최대값 127보다 1 큰 수

ConsoleWriteLine(x);  // 128 출력

sbyte y = (sbyte)x; <-------- 오버플로우 발생

Console.WriteLine(y);  // -128 출력
```
##### 2. 크기가 다른 부동 소수점 형식 사이의 변환
- 부동 소수점 형식의 특성상 **Overflow가 존재하지 않음**
- 그러나 정밀성에 손상을 입는 문제가 발생
	- float 나 double은 소수를 이진수로 메모리에 보관(이진수로 표현하는 소수사가 완전하지 않은 것이 문제)
![[3. 데이터 형-20240405135714112.webp]]

##### 3. 부호 있는 정수 형식과 부호 없는 정수 형식 사이의 변환
- 최저 값 보다 작은 값을 저장해 Underflow 발생 가능 
![[3. 데이터 형-20240405135807427.webp]]

##### 4. 부동 소수점 형식과 정수 형식 사이의 변환
- 부동 소수점 형식의 변수를 정수 형식으로 변환하면 데이터에서 소수점 아래는 버리고 소수점 위의 값만 남김(반올림 없음)
- 0.1을 정수 형식으로 변환하면 0이 되지만, 0.9도 정수 형식으로 변환하면 0이 됨
![[3. 데이터 형-20240405135958737.webp]]

##### 5. 문자열을 숫자로, 숫자를 문자열로 변환
- 숫자 -> 문자열: ToString() 메서드 이용
- **Ex.**
	int a = 3;
	string b = a.Tostring();
- 문자열 -> 숫자: a.ToString() 메서드 이용
- **Ex.**
	int a = int.Parse("12345");
![[3. 데이터 형-20240405140505165.webp|400]]

### 데이터 형식 변환 규칙
- 정수 혁식에서의 묵시적 변환은 대상 형식이 원본 값을 수용할 수 있는 경우는 가능하고 그렇지 않은 경우는 명시적 변환이 요구된다.
- **Ex.**
	 `long myLong = 123L;`
	 `int myInt = myLong;` // 묵시적 형 변환 안됨
	 `int myInt = (int)myLong;`// 명시적 형 변환 가능
- 정수와 실수 사이의 형 변환은 항상 명시적이어야 한다.
- 정수형에서 decimal형으로 묵시적 형 변환은 가능하나 decimal형과 실수 사이의 형 변환은 항상 명시적이어야 한다.
- char 형은 수치 형으로 묵시적 형 변환이 가능하나 그 반대는 성립하지 않는다.

### 상수(Constant)
- 변수와는 달리 그 안에 담긴 데이터를 절대 바꿀 수 없는 메모리 공간
- 변수를 선언하고 프로그래머가 바꾸지 않으면 되지, 왜 상수가 필요한가?
	- **프로그래머는 사람이기 때문에 실수를 하는 것을 방지하기 위해서**
- 상수 선언 방법: 아래와 같이 const 키워드를 이용하여 선언
![[3. 데이터 형-20240405140926831.webp]]

### 열거형(Enumeration)
- 같은 범주에 속하는 여러 개의 상수를 선언할 때
- enum 키워드를 이용하여 선언
![[3. 데이터 형-20240405141014042.webp]]

### Nullable 형식
- C#컴파일러는 변수의 메모리 공간에 반드시 어떤 값이든 넣도록 강제함
- 하지만 프로그래밍을 하다 보면 어떤 값도 가지지 않는 변수가 필요할 때가 생김. 0이 아닌, 정말 비어있는 변수, 즉 null한 변수가 필요할 때가 생김
- Nullable 형식은 이런 경우를 위해 사용
	- 데이터 형식 뒤에 **'?'** 만 붙여주면 끝
	- **Ex.**
		`int? a = null;`
		`float? b = null;`
		`double? c = null;`
### Var : 자동 형식 지정
- C#은 강력한 형식 검사를 하는 언어이지만, 약한 형식 검사를 하는 언어의 편리함도 지원
- int, string 같은 명시적 형식 대신 var 를 사용해서 변수를 선언하면 컴파일러가 자동으로 해당 변수의 형식을 지정
	- 선언과 동시 초기화 필수
	- 지역변수로만 사용
	- **Ex.**
		var a = 3;             // a는 int 형식
		var b = "Hello";   // b는 string 형식