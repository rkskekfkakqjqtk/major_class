### 닷넷 .NET 프레임워크
- 닷넷 프레임워크는 2002년 **Microsoft**에서 발표한 애플리케이션 개발환경으로서 **프로세스 가상 머신**에 속한다.
	- 닷넷 프레임워크 기반 애플리케이션은 반드시 닷넷 프레임워크가 설치된 환경에서만 실행된다.
- 닷넷 프레임워크는 **CLR**과 **BCL**로 구성되어 있다.
---
### CLR(Common Language RunTime)
- **CLR**이란 닷넷 프레임워크 애플리케이션을 실행하는데 필요한 실행 엔진이다.
	- IL언어를 JIT 컴파일러를 이이용해 기계어로 변환
	- 가비지 컬렉터를 제공해 동적 메모리 할당 및 회수
- CLR이 제공하는 서비스
	- 코드관리, 메모리관리, 안정된 데이터형 관리
	- IL을 원시 코드로 변환, 예외 처리
	- 데이터형에 대한 정보 구하기
	- 매니지드 객체에 대한 메모리 관리
---
### BCL(Base Class Library)
- **BCL**은 닷넷에서 제공하는 방대한 **기본 클래스 라이브러리**이다.
- BCL에 포함된 클래스의 목록 및 기능의 예
	- 기본 타입에 대한 정보 제공
	- 배열, 연결리스트, 큐 등의 컬렉션 클래스
	- 그래픽 라이브러리(GDI+)
	- 스레드와 동기화 클래스
	- 각종 컨트롤
	- 네트워크와 인터넷 프로그래밍
---
### CLS(Common Language Specification)
- CLS는 닷넷 런타임을 쓸 수 있는 언어가 되기 위한 최소한의 규정이다. (CLS의 예)
	- 전역함수나 변수는 정의할 수 없다.
	- 부호 없는 정수형을 강제화 하지 않는다.
- 닷넷 언어들은 CLS의 모든 규칙을 다 만족하지 않아도 상관없다.
- CLS는 언어를 만드는 자들을 위한 명세이므로 응용 프로그램 개발자가 CLS의 모든 면을 자세히 알 필요는 없다.
---
### CTS(Common Type System)
- CTS는 모든 닷넷에서 공동으로 사용하는 자료형 체계를 정의한다.
- CTS는 정수, 실수 같은 기본형 뿐만 아니라 클래스 배열 같은 복잡한 타입까지 계층이 잘 정의되어 있다.
- 각 언어들은 CTS가 정의된 내장 형식을 사용할 수 있는데 편의상 언어별로 고유한 키워드를 정의하여 사용한다.
---
### 닷넷 프로그램 실행 단계
##### 컴파일 과정
- 컴파일러를 이용하여 소스 코드를 컴파일 하면 IL코드가 생성된다.
- 출력 파일은 exe파일이지만 아직 프로세스가 이해할 수 있는 기계어가 아니다.
##### 실행 단계
- IL 코드 파일을 실행했을 때 CLR 런타임이 자동적으로 프로세서가 이해할 수 있는 기계어로 변환한다.
---
### CLR의 역할

![[1. 닷넷 프레임워크-20240405091638855.webp|600]]

---
### 닷넷 언어와 CLR
- 각 언어마다 컴파일러는 달라도 하나의 런타임을 사용하고 서로 컴파일한 결과를 이해할 수 있기 때문에 다른 닷넷 언어와 호환 가능

![[1. 닷넷 프레임워크-20240405091856176.webp|600]]

---
### IL(Intermediate Language) 코드
- 서로 다른 언어라 할지라도 컴파일한 결과가 IL코드로 저장되기 때문에 닷넷 언어간의 호환이 가능하다.
- 모든 닷넷 언어는 기본 클래스 라이브러리(BCL)를 이용한다.
	- BCL 역시 IL 코드로 저장되어 있다.
- IL 코드를 매니지드 코드라고 부르기도 한다.

### 메타 데이터
- 메타 데이터는 데이터를 위한 데이터이다.
	- **Ex.** 그림을 나타내는 컬러 값이 사진에 대한 데이터이고, 그림의 너비와 높이, 해상도 등은 "원본 사진 데이터"를 위한 데이터로 이를 메타데이터라고 한다.
- CLR에서 동작하는 실행 파일은 메타 데이터를 제공하고 외부에서 이런 정보를 리플렉션을 통해 사용할 수 있다.
- 닷넷 호환 언어는 IL 코드와 그에 대한 메타 데이터를 생성하게끔 만들어야 한다.

### 어셈블리(Assembly)
- 어셈블리 닷넷 프레임워크 애플리케이션의 기본 블록 단위이다. 즉, 실행파일(exe, DLL)이 어셈블리이다.
- 보통 DLL 파일 단위로 다루어지며 하나 또는 여러 모듈(파일)로 구성된다.
	- 모듈 중 하나는 다른 모듈의 목록을 관리하는 매니 페스트 데이터를 담고 있어야 한다.
- 버전 관리나 배포할 때도 어셈블리 단위로 관리한다.
##### Private Assembly
- 하나의 애플리케이션에서만 사용되는 것으로 애플리케이션이 설치된 디렉토리에 같이 저장된다.
- 애플리케이션 내에서만 어셈블리 이름만 유일하면 된다.
##### Shared Assembly
- 하나 이상의 애플리케이션에서 참조될 수 있는 것
- 어셈블리를 공유해서 쓰려면 이름을 지정하고 버전 번호와 함께 명시적으로 선언해야 한다.
---
### C#과 닷넷 프레임워크
##### C#은 Microsoft가 닷넷 프레임워크를 위해 만든 언어이기 때문에 닷넷 프레임워크를 공부하기에 가장 좋은 언어는 C#이다.

##### C#을 통해 닷넷 환경을 이애한다면 다른 닷넷 언어를 이용하여 프로그램을 작성하는 것은 어려운 일이 아니다.
---
### 닷넷 코어
- 닷넷 코어는 다중 플랫폼(맥, 리눅스 등)에서 실행할 수 있도록 만들어진 닷넷 플렛폼이다.
- 다중 플랫폼 지원이라는 장점 이면에 특정 플랫폼에서만 가능한 기능을 지원할 수 없다는 단점도 있다.
	- 이는 기반 라이브러리가 달라진다는 문제점이 있어 닷넷 코어와 닷넷 프레임워크는 하부구조는 공유하지만 기반 라이브러리 단계부터 독자적인 구현으로 이루어진다.
---
### 닷넷 코어와 닷넷 프레임워크 구조 차이

![[1. 닷넷 프레임워크-20240405093649128.webp]]

---
### 닷넷 표준
- 기반 라이브러리가 Base Class Library, Core Library로 나뉘면서 이를 바탕으로 제작되는 라이브러리 재사용에 문제가 발생한다.
- 이와 같은 기반 라이브러리 불일치를 해결하기 위해 다시 그들만의 표준을 만든 규격이 닷넷 표준 라이브러리이다.

![[1. 닷넷 프레임워크-20240405093807423.webp|600]]
- 닷넷 표준 라이브러리에서 작성된 라이브러리는 닷넷 코어와 닷넷 프레임워크 위에서 아무런 변경없이 사용할 수 있다.
---
### 가비지 콜렉팅
##### C++ 언어 메모리 관리
- C/C++ 프로그램에서 메모리를 쓰려면 먼저 메모리를 할당하고 다 사용한 후 반드시 해제해주어야 한다.
- **장점**
	- 메모리를 효율적으로 이용할 수 있다.
- **단점**
	- 메모리 관리 코드에 항상 많은 버그를 유발한다
	- 메모리 리크(Memory Leak)가 발생할 수 있다.
##### 닷넷에서 메모리 관리
- 닷넷에서 사용하는 메모리 관리 방법은 **가비지 콜렉션**이다.
	- 프로그램이 사용했던 메모리 중에서 안 쓰는 메모리를 실행 도중에 검사해서 다시 복원하는 것
	- 힙에서 더 이상 쓰이지 않는 객체를 찾아서 제거
	- 런타임에 자동으로 실행되지만 경우에 따라 프로그램 내에서 직접 부를 수도 있다.
	- System 네임스페이스에 GC로 제공한다.
		- `System.GC.Collect();
##### C# 언어 메모리 관리
- C#언어에서 할당되는 객체는 모두 가비지 콜렉터에 의해 관리된다.
- 가비지 콜렉터는 코드에서 사용했던 객체의 레퍼런스 카운트를 검사하고 더 이상 참조되지 않는 객체를 메모리에서 제거한다.
	- `GC.Collect() //가비지 콜렉터를 호출한다.
	- `GC.WaitForPendingFinalizers() // 가비지 콜렉팅이 끝날 때까지 기다린다.`
---
