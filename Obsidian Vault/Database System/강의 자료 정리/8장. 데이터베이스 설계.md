### 데이터베이스 설계 단계
##### 데이터베이스 설계
- 사용자들의 요구 사항을 고려해서 데이터베이스를 생성하는 과정
- 품질 좋은 데이터베이스 생성 조건
	- 데이터의 일관성과 무결성을 유지
	- 사용자가 이해하기 쉽고 접근하기 편해야 함
	- 구성원들의 요구 사항 만족성 여부
---
##### 데이터베이스 설계의 2가지 방법
- E-R 모델과 릴레이션 변환 규칙을 이용한 DB설계
- 정규화를 이용한 DB 설계
---
##### E-R 모델과 릴레이션 변환 규칙을 이용햔 DB 설계
1. 요구사항 분석
	- 구성원들의 사용하는 용도 파악
	- 필요한 데이터의 종류와 처리 방법에 대한 요구 사항 수집 → 요구 사항 명세서로 작성함
2. 개념적 설계
	- DBMS에 독립적인 개념적 구조 설계
	- 개념적 모델: 사용자의 요구 사항 명세서를 개념적 데이터 모델로 변환하는 일
	- E-R모델은 데이터 요소와 요소간의 관계를 E-R 다이어그램으로 표현함
3. 논리적 설계
	- 개념적 설계를 기반으로 DBMS에 논리적인 구조 설계
	- 논리적 모델링: E-R다이어그램을 릴레이션 스키마로 변환하는 작업
4. 물리적 설계
	- 논리적 구조를 기반으로 물리적 구조를 설계
	- 물리적 구조 : 내부 저장 구조, 접근 경로 등을 의미
	- 저장 레코드 ,인덱스의 구조 등을 설계, 저장된 데이터와 인덱스를 빠르게 접근하는 탐색 기법 등을 정의
5. 구현
	- 데이터 정의어를 이용하여 DB를 실제로 생성함
---
![[8장. 데이터베이스 설계-20240423032533263.webp]]

---
###### DB에 대한 사용자들의 요구 사항 수집 및 분석
- 요구 사항 명세서 작성
	- DBA가 양식을 만들어 배포함
	- 만약 기존 시스템을 대체할 신규 시스템을 구축한다면, 기존 시스템 + 신규 요구사항을 같이 정리해야 함
![[8장. 데이터베이스 설계-20240423032640112.webp]]
---
##### 요구사항으로부터 개체와 개체 간의 관계 분석
- E-R 다이어그램으로 작성함
	- 개체, 주요 속성, 키 속성을 선별
	- 개체 간의 관계를 결정함
	- E-R 다이어그램으로 최종 표현함
![[8장. 데이터베이스 설계-20240423032758519.webp]]
---
##### 개체와 속성 추출
- 요구 사항 명세서로부터 개체 찾기
	- 개체, 속성을 구분하기 어렵다
	- 개체는 대체적으로 요구사항 내에서 **명사**를 찾아야 한다.
	- 명사가 여러 개이면 대표 명사 하나만 선택해야 함(나머지 명사는 개체의 속성이 될 수 없음)
	- 조직 자체는 가리키는 것은 배제함
	- 명사라고 생각하는 것도 명사가 **아닐 수 있음**
	- 찾아낸 명사들로부터 개체와 속성을 가려야 함
---
##### 관계 추출
- 요구 사항 명세서로부터 관계 찾기
	- 관계는 대체적으로 요구사항 내에서 **동사**를 찾아야 한다.
	- 동사가 여러 개이면 대표 동사 하나만 선택해야 함
	- 매핑 카디널리티 : 1:1, 1:n, n:m
	- 관계가 필수적(이중 실선)인지 선택적(실선)인지 참여 특성을 결정해야 함
---
##### E-R 다이어그램
- 4개의 개체와 3개의 관계를 표현
![[8장. 데이터베이스 설계-20240423033302108.webp|600]]
---
##### DBMS 특성에 맞게 논리적 모델을 사용함
- 일반적으로 관계 데이터 모델을 이용함
![[8장. 데이터베이스 설계-20240423033338624.webp|600]]
---
##### E-R 다이어그램에서 릴레이션 스키마로 변환하기
- 관계 데이터 모델(릴에이션 스키마) 기준에서 둘 간의 차이점
![[8장. 데이터베이스 설계-20240423033430293.webp]]
---
##### 릴레이션 스키마 변환규칙
1. 모든 개체는 릴레이션으로 변환한다.
2. m:n 관계는 릴레이션으로 변환한다
3. 1:n 관계는 외래키로 표현한다.
4. 1:1 관계는 외래키로 표현한다.
5. 다중 값 속성은 릴레이션으로 변환한다.
- 기타 고려 사항
	- 속성이 많은 관계는 관계 유형에 상관없이 릴레이션으로 변환 가능
		- n:m 관계가 아닐 경우 불필요한 릴레이션 개수가 많아져서 DBMS에 부담임
---
